1. Fichier git_tools/cli.py
"""Point d'entr√©e principal pour Git Workflow Tool.

Ce module g√®re :
- L'analyse des arguments en ligne de commande
- L'initialisation du logger appropri√©
- Le routage vers les diff√©rents workflows
- Le menu interactif (si aucune commande n'est sp√©cifi√©e)
- Les options globales (--version, --help, --non-interactive)

Usage:
    python -m git_tools [OPTIONS] COMMAND [ARGS]

Options globales:
    --version               Affiche la version et quitte
    --non-interactive       D√©sactive le mode interactif
    --debug                 Active les messages de debug
    --force-color           Force l'affichage des couleurs
    --help                  Affiche cette aide

Commandes disponibles:
    commit      Effectue un commit et push
    release     Cr√©e une nouvelle release
    sync        Synchronise avec le d√©p√¥t distant
    tag         G√®re les tags Git
"""

import os
import sys
import argparse
from typing import Optional, Dict, Callable, Any, NoReturn
from importlib.metadata import version, PackageNotFoundError

from git_tools.logger import get_logger, Logger
from git_tools import __version__ as package_version
from git_tools.workflows import (
    commit_and_push_workflow,
    create_release_workflow,
    sync_with_remote_workflow,
    manage_tags_workflow,
)

# --- Constantes ---
DEFAULT_COMMAND = "menu"  # Commande par d√©faut si aucune n'est sp√©cifi√©e
COMMAND_MAPPING: Dict[str, Callable[[Logger, argparse.Namespace], None]] = {
    "commit": commit_and_push_workflow,
    "release": create_release_workflow,
    "sync": sync_with_remote_workflow,
    "tag": manage_tags_workflow,
    "menu": None,  # G√©r√© s√©par√©ment
}

# --- Fonctions utilitaires ---
def get_package_version() -> str:
    """R√©cup√®re la version du package depuis les m√©tadonn√©es."""
    try:
        return version("git-tools")
    except PackageNotFoundError:
        return package_version  # Fallback si pas install√© en mode editable

def print_version() -> NoReturn:
    """Affiche la version et quitte le programme."""
    print(f"Git Workflow Tool v{get_package_version()}")
    sys.exit(0)

def print_help() -> NoReturn:
    """Affiche l'aide et quitte le programme."""
    print(__doc__.strip())
    sys.exit(0)

def parse_args(args: Optional[list] = None) -> argparse.Namespace:
    """Parse les arguments de la ligne de commande.

    Args:
        args: Liste d'arguments √† parser (par d√©faut sys.argv[1:])

    Returns:
        argparse.Namespace: Objet contenant les arguments pars√©s
    """
    parser = argparse.ArgumentParser(
        description="Git Workflow Tool - Outil avanc√© pour g√©rer vos workflows Git",
        add_help=False,  # On g√®re nous-m√™mes --help pour plus de contr√¥le
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Options globales
    parser.add_argument(
        "--version",
        action="store_true",
        help="Affiche la version et quitte",
    )
    parser.add_argument(
        "--non-interactive",
        action="store_true",
        help="D√©sactive le mode interactif (pour les scripts/CI)",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Active les messages de debug",
    )
    parser.add_argument(
        "--force-color",
        action="store_true",
        help="Force l'affichage des couleurs m√™me si stdout n'est pas un TTY",
    )
    parser.add_argument(
        "--help",
        action="store_true",
        help="Affiche cette aide",
    )

    # Sous-commandes
    subparsers = parser.add_subparsers(
        dest="command",
        title="Commandes disponibles",
        metavar="COMMAND",
        required=False,
    )

    # Commande 'commit'
    commit_parser = subparsers.add_parser(
        "commit",
        help="Effectue un commit et push",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    commit_parser.add_argument(
        "-m", "--message",
        help="Message de commit (d√©sactive le prompt interactif)",
    )
    commit_parser.add_argument(
        "--amend",
        action="store_true",
        help="Modifie le dernier commit au lieu d'en cr√©er un nouveau",
    )

    # Commande 'release'
    release_parser = subparsers.add_parser(
        "release",
        help="Cr√©e une nouvelle release",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    release_parser.add_argument(
        "--type",
        choices=["major", "minor", "patch"],
        help="Type de release (major/minor/patch)",
    )
    release_parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Simule la cr√©ation de release sans appliquer les changements",
    )

    # Commande 'sync'
    subparsers.add_parser(
        "sync",
        help="Synchronise avec le d√©p√¥t distant",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Commande 'tag'
    tag_parser = subparsers.add_parser(
        "tag",
        help="G√®re les tags Git",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    tag_parser.add_argument(
        "action",
        choices=["list", "create", "delete"],
        help="Action √† effectuer sur les tags",
    )
    tag_parser.add_argument(
        "--name",
        help="Nom du tag (pour create/delete)",
    )
    tag_parser.add_argument(
        "--message",
        help="Message du tag (pour create)",
    )

    return parser.parse_args(args)

def display_interactive_menu(logger: Logger) -> None:
    """Affiche le menu interactif principal.

    Args:
        logger: Instance de Logger pour les interactions utilisateur
    """
    while True:
        logger.info("\n" + "="*50)
        logger.info("üêô Git Workflow Tool - Menu Principal")
        logger.info("="*50)
        logger.info("1. Commit & Push")
        logger.info("2. Cr√©er une Release")
        logger.info("3. Synchroniser avec le d√©p√¥t distant")
        logger.info("4. G√©rer les Tags")
        logger.info("5. Quitter")

        choice = logger.prompt("Choisissez une option (1-5)")

        if choice == "1":
            commit_and_push_workflow(logger, argparse.Namespace())
        elif choice == "2":
            create_release_workflow(logger, argparse.Namespace())
        elif choice == "3":
            sync_with_remote_workflow(logger, argparse.Namespace())
        elif choice == "4":
            manage_tags_workflow(logger, argparse.Namespace())
        elif choice in ("5", "q", "quit", "exit"):
            logger.info("Au revoir !")
            sys.exit(0)
        else:
            logger.warning("Option invalide. Veuillez r√©essayer.")

def run_command(
    command: str,
    logger: Logger,
    args: argparse.Namespace,
) -> None:
    """Ex√©cute la commande sp√©cifi√©e.

    Args:
        command: Nom de la commande √† ex√©cuter
        logger: Instance de Logger
        args: Arguments pars√©s

    Raises:
        SystemExit: Si la commande est invalide
    """
    workflow = COMMAND_MAPPING.get(command)

    if workflow is None:
        if command == DEFAULT_COMMAND:
            display_interactive_menu(logger)
        else:
            logger.error(f"Commande inconnue: {command}")
            print_help()

    try:
        workflow(logger, args)
    except Exception as e:
        logger.error(f"√âchec de l'ex√©cution de la commande: {str(e)}")
        if logger.confirm("Voulez-vous voir la trace compl√®te de l'erreur?", default=False):
            raise
        sys.exit(1)

def setup_environment(args: argparse.Namespace) -> None:
    """Configure l'environnement en fonction des arguments.

    Args:
        args: Arguments pars√©s
    """
    if args.debug:
        os.environ["DEBUG"] = "1"
    if args.force_color:
        os.environ["FORCE_COLOR"] = "1"

def main(args: Optional[list] = None) -> None:
    """Point d'entr√©e principal de l'application.

    Args:
        args: Liste d'arguments (pour les tests). Par d√©faut sys.argv[1:].
    """
    # Parse les arguments
    args = parse_args(args)

    # G√®re les options globales
    if args.version:
        print_version()
    if args.help:
        print_help()

    # Configure l'environnement
    setup_environment(args)

    # Initialise le logger appropri√©
    logger = get_logger(
        non_interactive=args.non_interactive,
        force_color=args.force_color,
    )

    # D√©termine la commande √† ex√©cuter
    command = args.command if args.command else DEFAULT_COMMAND

    # Ex√©cute la commande
    run_command(command, logger, args)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger = get_logger(non_interactive=True)
        logger.error("\nOp√©ration interrompue par l'utilisateur.")
        sys.exit(1)
    except Exception as e:
        logger = get_logger(non_interactive=True)
        logger.error(f"Erreur inattendue: {str(e)}")
        sys.exit(1)

2. Documentation Markdown (CLI.md)
# Git Workflow Tool - Interface en Ligne de Commande

## Table des mati√®res
1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Utilisation de base](#utilisation-de-base)
4. [Options globales](#options-globales)
5. [Commandes disponibles](#commandes-disponibles)
   - [commit](#commit)
   - [release](#release)
   - [sync](#sync)
   - [tag](#tag)
6. [Mode interactif](#mode-interactif)
7. [Exemples d'utilisation](#exemples-dutilisation)
8. [Variables d'environnement](#variables-denvironnement)
9. [Int√©gration CI/CD](#int√©gration-cicd)
10. [D√©veloppement et extension](#d√©veloppement-et-extension)

---

## Introduction
`git_tools/cli.py` est le **point d'entr√©e principal** de Git Workflow Tool. Il offre :
- Une **interface en ligne de commande** compl√®te
- Un **menu interactif** pour les utilisateurs d√©butants
- Un **mode non-interactif** pour les scripts et CI/CD
- Une **architecture modulaire** facile √† √©tendre

---

## Installation
### Via pip (recommand√©)
```bash
pip install git-tools
En d√©veloppement
git clone https://github.com/votre-repo/git-tools.git
cd git-tools
pip install -e .

Utilisation de base
# Lancer le menu interactif
git-tools

# Ex√©cuter une commande sp√©cifique
git-tools commit -m "Mon message de commit"

# Afficher l'aide
git-tools --help

# Afficher la version
git-tools --version

Options globales



Option
Description



--version
Affiche la version et quitte


--non-interactive
D√©sactive les prompts interactifs (pour les scripts/CI)


--debug
Active les messages de debug


--force-color
Force l'affichage des couleurs m√™me si stdout n'est pas un TTY


--help
Affiche l'aide et quitte


Exemple :
git-tools --non-interactive --debug commit -m "Fix bug"

Commandes disponibles
commit
Effectue un commit et push vers le d√©p√¥t distant.
Usage :
git-tools commit [OPTIONS]
Options :



Option
Description



-m, --message
Message de commit (d√©sactive le prompt)


--amend
Modifie le dernier commit au lieu d'en cr√©er un nouveau


Exemples :
# Mode interactif
git-tools commit

# Mode non-interactif avec message
git-tools --non-interactive commit -m "Fix critical bug"

release
Cr√©e une nouvelle release (tag + push).
Usage :
git-tools release [OPTIONS]
Options :



Option
Description



--type
Type de release (major/minor/patch)


--dry-run
Simule la cr√©ation sans appliquer les changements


Exemples :
# Cr√©er une release patch
git-tools release --type patch

# Simulation
git-tools release --type minor --dry-run

sync
Synchronise le d√©p√¥t local avec le d√©p√¥t distant.
Usage :
git-tools sync
Exemple :
git-tools --non-interactive sync

tag
G√®re les tags Git (liste, cr√©ation, suppression).
Usage :
git-tools tag ACTION [OPTIONS]
Actions disponibles :



Action
Description



list
Liste tous les tags


create
Cr√©e un nouveau tag


delete
Supprime un tag existant


Options :



Option
Description



--name
Nom du tag (pour create/delete)


--message
Message du tag (pour create)


Exemples :
# Lister les tags
git-tools tag list

# Cr√©er un tag
git-tools tag create --name v1.0.0 --message "Version 1.0.0"

# Supprimer un tag
git-tools tag delete --name v1.0.0

Mode interactif
Si aucune commande n'est sp√©cifi√©e, l'outil lance un menu interactif :
üêô Git Workflow Tool - Menu Principal
==================================================
1. Commit & Push
2. Cr√©er une Release
3. Synchroniser avec le d√©p√¥t distant
4. G√©rer les Tags
5. Quitter
Navigation :

Utilisez les num√©ros pour s√©lectionner une option
Suivez les instructions √† l'√©cran

Exemple :
git-tools  # Lance le menu interactif

Exemples d'utilisation
1. Workflow de commit complet
# Mode interactif
git-tools commit

# Mode non-interactif (pour CI)
git-tools --non-interactive commit -m "Update README [skip ci]"
2. Cr√©ation d'une release
# Avec confirmation interactive
git-tools release --type minor

# Sans interaction (pour scripts)
git-tools --non-interactive release --type patch
3. Synchronisation
# Mode interactif
git-tools sync

# Mode silencieux
git-tools --non-interactive sync
4. Gestion des tags
# Lister les tags
git-tools tag list

# Cr√©er un tag annot√©
git-tools tag create --name v2.0.0 --message "Version 2.0.0"

# Supprimer un tag
git-tools --non-interactive tag delete --name v2.0.0

Variables d'environnement



Variable
Description
Valeurs possibles



DEBUG
Active les messages de debug
1, true, yes


FORCE_COLOR
Force l'affichage des couleurs
1, true, yes


NO_COLOR
D√©sactive compl√®tement les couleurs
Toute valeur


GIT_TOOLS_NON_INTERACTIVE
D√©sactive le mode interactif (alternative √† --non-interactive)
Toute valeur


Exemple :
DEBUG=1 git-tools commit

Int√©gration CI/CD
Pour utiliser Git Workflow Tool dans vos pipelines CI/CD :
GitHub Actions
- name: Commit changes
  run: |
    git-tools --non-interactive commit -m "Auto-commit from CI [skip ci]"
    git-tools --non-interactive sync
GitLab CI
script:
  - git-tools --non-interactive release --type patch
Jenkins
sh 'git-tools --non-interactive --debug sync'

D√©veloppement et extension
Ajouter une nouvelle commande

Cr√©er une fonction workflow dans git_tools/workflows.py :
def ma_nouvelle_commande(logger: Logger, args: argparse.Namespace) -> None:
    logger.info("Ex√©cution de ma nouvelle commande...")
    # ... logique m√©tier

Mettre √† jour COMMAND_MAPPING dans cli.py :
COMMAND_MAPPING = {
    # ... commandes existantes ...
    "ma-commande": ma_nouvelle_commande,
}

Ajouter le parser de commande dans parse_args() :
ma_commande_parser = subparsers.add_parser(
    "ma-commande",
    help="Description de ma commande",
)
ma_commande_parser.add_argument(
    "--option",
    help="Description de l'option",
)


Structure du projet
git_tools/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ cli.py          # Point d'entr√©e (ce fichier)
‚îú‚îÄ‚îÄ logger.py       # Gestion des logs et interactions
‚îú‚îÄ‚îÄ workflows.py    # Logique m√©tier des commandes
‚îî‚îÄ‚îÄ utils/          # Fonctions utilitaires
Bonnes pratiques

Toujours utiliser le logger pour les interactions utilisateur :
def ma_commande(logger: Logger, args: argparse.Namespace):
    if logger.confirm("Voulez-vous continuer?"):
        # ...

G√©rer les erreurs proprement :
try:
    # ... op√©ration risqu√©e ...
except Exception as e:
    logger.error(f"√âchec: {str(e)}")
    if args.debug:
        raise
    sys.exit(1)

Documenter les nouvelles commandes dans le __doc__ du module.

Respecter le typage pour une meilleure maintenabilit√© :
from typing import Optional

def ma_fonction(logger: Logger, arg: str, option: Optional[bool] = None) -> None:
    ...



R√©solution des probl√®mes
Probl√®me : Commande non trouv√©e
Sympt√¥me :
Erreur: Commande inconnue: ma-commande
Solutions :

V√©rifiez que la commande est bien dans COMMAND_MAPPING
Assurez-vous que le parser de commande est bien ajout√© dans parse_args()
V√©rifiez la casse (les commandes sont sensibles √† la casse)


Probl√®me : L'outil plante en mode non-interactif
Sympt√¥me :
L'outil demande une confirmation alors qu'il est en mode non-interactif.
Solutions :

V√©rifiez que vous passez bien --non-interactive

Dans votre code, utilisez toujours les m√©thodes du logger :
# ‚úÖ Bonne pratique
if logger.confirm("Continuer?", default=True):
    # ...

# ‚ùå √Ä √©viter
if input("Continuer? [y/N]").lower().startswith("y"):
    # ...

Assurez-vous que vos fonctions workflow acceptent un param√®tre args avec les bonnes valeurs par d√©faut.



Probl√®me : Les couleurs ne s'affichent pas
Sympt√¥mes :

Les ic√¥nes s'affichent mais pas les couleurs
Tout est en noir et blanc

Solutions :

Forcez les couleurs avec --force-color
V√©rifiez que NO_COLOR n'est pas d√©fini
Assurez-vous que votre terminal supporte les couleurs ANSI
Essayez avec un autre terminal (ex: iTerm2, Windows Terminal)


Probl√®me : Erreur de permission
Sympt√¥me :
Erreur: Permission denied (publickey).
Solutions :

Configurez votre cl√© SSH avec ssh-add
Utilisez --non-interactive pour √©viter les prompts de mot de passe
V√©rifiez que votre agent SSH est en cours d'ex√©cution :eval "$(ssh-agent -s)"
ssh-add ~/.ssh/votre_cle_privee



Changelog
v1.0.0 (2023-11-20)

Premi√®re version stable
Support des commandes commit, release, sync, tag
Mode interactif et non-interactif
Int√©gration compl√®te avec le syst√®me de logging

v1.1.0 (2023-11-25)

Ajout du support des variables d'environnement
Am√©lioration de la gestion des erreurs
Meilleure documentation
Ajout de l'option --dry-run pour les releases


Licence
Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus de d√©tails.

---

## **3. Points cl√©s de l'impl√©mentation**

### **Architecture modulaire**
1. **S√©paration des responsabilit√©s** :
   - `cli.py` : Gestion des arguments et routage
   - `logger.py` : Interactions utilisateur
   - `workflows.py` : Logique m√©tier

2. **Extensibilit√©** :
   - Ajout de nouvelles commandes en 3 √©tapes (fonction + mapping + parser)
   - Interface `Logger` bien d√©finie pour une substitution facile

3. **Gestion des modes** :
   - **Interactif** : Menu complet avec confirmations
   - **Non-interactif** : Id√©al pour CI/CD
   - **Hybride** : Certaines commandes peuvent √™tre interactives m√™me en mode non-interactif global

### **Gestion des erreurs robuste**
- **Capture des exceptions** au niveau le plus haut (`main()`)
- **Affichage des traces compl√®tes** seulement en mode debug
- **Gestion propre des interruptions** (Ctrl+C)

### **Int√©gration CI/CD**
- **Mode non-interactif** par d√©faut pour les environnements CI
- **Sortie propre** (codes de retour appropri√©s)
- **Pas de prompts bloquants** en mode non-interactif

### **Exp√©rience utilisateur**
- **Menu interactif clair** avec num√©rotation
- **Messages coloris√©s** pour une meilleure lisibilit√©
- **Aide contextuelle** pour chaque commande
- **Valeurs par d√©faut intelligentes** en mode non-interactif

### **Bonnes pratiques respect√©es**
- **Typage strict** avec annotations Python
- **Docstrings compl√®tes** (format Google)
- **Respect de PEP 8** et validation Ruff
- **Gestion des d√©pendances** via `importlib.metadata`
- **S√©paration claire** entre logique m√©tier et pr√©sentation
