 Fichier logger.py
"""Module de gestion des logs et interactions utilisateur pour Git Workflow Tool.

Ce module fournit une interface unifi√©e pour :
- L'affichage de messages (info, succ√®s, erreur, avertissement)
- La gestion des confirmations utilisateur
- La saisie interactive/non-interactive
- Le logging en mode debug

Classes :
    Logger : Interface abstraite pour les op√©rations de logging.
    ConsoleLogger : Impl√©mentation concr√®te pour la sortie console.
    SilentLogger : Impl√©mentation silencieuse (pour les scripts non-interactifs).
"""

import os
import sys
from abc import ABC, abstractmethod
from typing import Optional, Protocol, runtime_checkable

# --- Constantes de style ---
class Color:
    """Codes ANSI pour la colorisation des sorties console."""
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"

# --- Ic√¥nes visuelles ---
ICON_SUCCESS = f"{Color.OKGREEN}‚úì{Color.ENDC}"
ICON_ERROR = f"{Color.FAIL}‚úó{Color.ENDC}"
ICON_INFO = f"{Color.OKBLUE}‚Ñπ{Color.ENDC}"
ICON_WARN = f"{Color.WARNING}‚ö†{Color.ENDC}"
ICON_DEBUG = f"{Color.HEADER}üêõ{Color.ENDC}"
ICON_INPUT = f"{Color.BOLD}‚ùØ{Color.ENDC}"

@runtime_checkable
class Logger(Protocol):
    """Interface pour les op√©rations de logging et d'interaction utilisateur."""

    def info(self, message: str, newline: bool = True) -> None:
        """Affiche un message informatif."""
        ...

    def success(self, message: str, newline: bool = True) -> None:
        """Affiche un message de succ√®s."""
        ...

    def error(self, message: str, newline: bool = True) -> None:
        """Affiche un message d'erreur."""
        ...

    def warning(self, message: str, newline: bool = True) -> None:
        """Affiche un message d'avertissement."""
        ...

    def debug(self, message: str, newline: bool = True) -> None:
        """Affiche un message de debug (si DEBUG=1)."""
        ...

    def confirm(
        self,
        prompt: str,
        default: Optional[bool] = None,
        abort: bool = False,
    ) -> bool:
        """Demande une confirmation √† l'utilisateur.

        Args:
            prompt: Message √† afficher.
            default: Valeur par d√©faut (None = aucune valeur par d√©faut).
            abort: Si True, quitte le programme en cas de r√©ponse n√©gative.

        Returns:
            bool: True si l'utilisateur a confirm√©, False sinon.
        """
        ...

    def prompt(
        self,
        prompt: str,
        default: Optional[str] = None,
        password: bool = False,
    ) -> str:
        """Demande une saisie utilisateur.

        Args:
            prompt: Message √† afficher.
            default: Valeur par d√©faut.
            password: Masquer la saisie (pour les mots de passe).

        Returns:
            str: La saisie utilisateur.
        """
        ...

class ConsoleLogger:
    """Impl√©mentation concr√®te de Logger pour la sortie console.

    G√®re :
    - La colorisation des messages
    - Les interactions utilisateur
    - Le mode debug (via la variable d'environnement DEBUG)
    - Les confirmations et saisies
    """

    def __init__(self, force_color: bool = False) -> None:
        """Initialise le logger console.

        Args:
            force_color: Forcer l'affichage des couleurs (m√™me si stdout n'est pas un TTY).
        """
        self._force_color = force_color
        self._debug_mode = os.environ.get("DEBUG", "0").lower() in ("1", "true", "yes")

    def _should_colorize(self) -> bool:
        """D√©termine si les couleurs doivent √™tre affich√©es."""
        if self._force_color:
            return True
        return sys.stdout.isatty()

    def _format_message(self, icon: str, message: str, color: str) -> str:
        """Formate un message avec ic√¥ne et couleur."""
        if not self._should_colorize():
            return f"{icon} {message}"
        return f"{color}{icon}{Color.ENDC} {message}"

    def info(self, message: str, newline: bool = True) -> None:
        """Affiche un message informatif."""
        formatted = self._format_message(ICON_INFO, message, Color.OKBLUE)
        self._print(formatted, newline)

    def success(self, message: str, newline: bool = True) -> None:
        """Affiche un message de succ√®s."""
        formatted = self._format_message(ICON_SUCCESS, message, Color.OKGREEN)
        self._print(formatted, newline)

    def error(self, message: str, newline: bool = True) -> None:
        """Affiche un message d'erreur."""
        formatted = self._format_message(ICON_ERROR, message, Color.FAIL)
        self._print(formatted, newline, file=sys.stderr)

    def warning(self, message: str, newline: bool = True) -> None:
        """Affiche un message d'avertissement."""
        formatted = self._format_message(ICON_WARN, message, Color.WARNING)
        self._print(formatted, newline)

    def debug(self, message: str, newline: bool = True) -> None:
        """Affiche un message de debug (si DEBUG=1)."""
        if not self._debug_mode:
            return
        formatted = self._format_message(ICON_DEBUG, message, Color.HEADER)
        self._print(formatted, newline)

    def _print(self, message: str, newline: bool, file=sys.stdout) -> None:
        """Affiche un message avec gestion des nouvelles lignes."""
        end = "\n" if newline else ""
        print(message, end=end, file=file, flush=True)

    def confirm(
        self,
        prompt: str,
        default: Optional[bool] = None,
        abort: bool = False,
    ) -> bool:
        """Demande une confirmation √† l'utilisateur.

        Args:
            prompt: Message √† afficher.
            default: Valeur par d√©faut (None = aucune valeur par d√©faut).
            abort: Si True, quitte le programme en cas de r√©ponse n√©gative.

        Returns:
            bool: True si l'utilisateur a confirm√©, False sinon.

        Raises:
            SystemExit: Si abort=True et que l'utilisateur refuse.
        """
        if default is None:
            choices = "[y/N]"
            default_str = "n"
        elif default:
            choices = "[Y/n]"
            default_str = "y"
        else:
            choices = "[y/N]"
            default_str = "n"

        while True:
            full_prompt = f"{ICON_INPUT} {prompt} {choices} "
            self._print(full_prompt, newline=False)
            choice = input().strip().lower()

            if not choice:
                confirmed = default if default is not None else False
            else:
                confirmed = choice.startswith("y")

            if confirmed:
                return True
            if not abort:
                return False
            self.error("Operation aborted by user.")
            sys.exit(1)

    def prompt(
        self,
        prompt: str,
        default: Optional[str] = None,
        password: bool = False,
    ) -> str:
        """Demande une saisie utilisateur.

        Args:
            prompt: Message √† afficher.
            default: Valeur par d√©faut.
            password: Masquer la saisie (pour les mots de passe).

        Returns:
            str: La saisie utilisateur.
        """
        if default:
            prompt_with_default = f"{prompt} [{default}]"
        else:
            prompt_with_default = prompt

        self._print(f"{ICON_INPUT} {prompt_with_default}", newline=False)

        if password:
            try:
                import getpass
                value = getpass.getpass("")
            except ImportError:
                # Fallback si getpass n'est pas disponible
                value = input()
        else:
            value = input()

        return value.strip() if value.strip() else default if default else ""

class SilentLogger:
    """Impl√©mentation silencieuse pour les scripts non-interactifs.

    Ignore tous les messages sauf les erreurs.
    """

    def info(self, message: str, newline: bool = True) -> None:
        """Ne fait rien (mode silencieux)."""
        pass

    def success(self, message: str, newline: bool = True) -> None:
        """Ne fait rien (mode silencieux)."""
        pass

    def warning(self, message: str, newline: bool = True) -> None:
        """Ne fait rien (mode silencieux)."""
        pass

    def debug(self, message: str, newline: bool = True) -> None:
        """Ne fait rien (mode silencieux)."""
        pass

    def error(self, message: str, newline: bool = True) -> None:
        """Affiche les erreurs sur stderr."""
        print(f"{ICON_ERROR} {message}", file=sys.stderr)

    def confirm(
        self,
        prompt: str,
        default: Optional[bool] = None,
        abort: bool = False,
    ) -> bool:
        """En mode silencieux, retourne toujours True (sauf si default=False)."""
        if default is False:
            return False
        return True

    def prompt(
        self,
        prompt: str,
        default: Optional[str] = None,
        password: bool = False,
    ) -> str:
        """En mode silencieux, retourne la valeur par d√©faut ou une cha√Æne vide."""
        return default if default is not None else ""

def get_logger(non_interactive: bool = False, force_color: bool = False) -> Logger:
    """Fabrique pour obtenir un logger adapt√© au contexte.

    Args:
        non_interactive: Si True, retourne un SilentLogger.
        force_color: Forcer l'affichage des couleurs.

    Returns:
        Logger: Une instance de Logger appropri√©e.
    """
    if non_interactive:
        return SilentLogger()
    return ConsoleLogger(force_color=force_color)

2. Documentation Markdown (LOGGER.md)
# Git Workflow Tool - Logger Module

## Table des mati√®res
1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Concepts cl√©s](#concepts-cl√©s)
4. [Utilisation](#utilisation)
   - [Initialisation](#initialisation)
   - [Affichage de messages](#affichage-de-messages)
   - [Interactions utilisateur](#interactions-utilisateur)
   - [Mode non-interactif](#mode-non-interactif)
5. [Exemples complets](#exemples-complets)
6. [Personnalisation](#personnalisation)
7. [Variables d'environnement](#variables-denvironnement)
8. [Bonnes pratiques](#bonnes-pratiques)

---

## Introduction
Le module `logger.py` fournit une interface unifi√©e pour :
- **G√©rer les sorties utilisateur** (messages, erreurs, succ√®s, avertissements)
- **Interagir avec l'utilisateur** (confirmations, saisies)
- **Supporter les modes interactif/non-interactif**
- **G√©rer le debugging** via une variable d'environnement

Il est con√ßu pour √™tre :
‚úÖ **Testable** (mockable facilement)
‚úÖ **Extensible** (nouveaux types de loggers)
‚úÖ **Consistant** (messages format√©s de mani√®re uniforme)
‚úÖ **Flexible** (comporte[...]s non-interactifs)

---

## Installation
Le module est inclus dans le package principal. Aucune installation suppl√©mentaire n'est n√©cessaire.

---

## Concepts cl√©s

### 1. L'interface `Logger`
D√©finit le contrat que doivent respecter tous les loggers :
```python
class Logger(Protocol):
    def info(self, message: str, newline: bool = True) -> None: ...
    def success(self, message: str, newline: bool = True) -> None: ...
    # ... (autres m√©thodes)
2. Impl√©mentations disponibles



Classe
Description



ConsoleLogger
Affiche des messages coloris√©s en console (mode interactif par d√©faut)


SilentLogger
Ignore la plupart des messages (pour les scripts non-interactifs)


3. Niveaux de messages



M√©thode
Ic√¥ne
Couleur
Utilisation typique



info()
‚Ñπ
Bleu
Messages informatifs


success()
‚úì
Vert
Op√©rations r√©ussies


warning()
‚ö†
Jaune
Avertissements


error()
‚úó
Rouge
Erreurs (affich√©es sur stderr)


debug()
üêõ
Violet
Messages de debug (si DEBUG=1)



Utilisation
Initialisation
from logger import get_logger

# Mode interactif (par d√©faut)
logger = get_logger()

# Mode non-interactif (silencieux)
logger = get_logger(non_interactive=True)

# Forcer les couleurs (m√™me si stdout n'est pas un TTY)
logger = get_logger(force_color=True)
Affichage de messages
logger.info("D√©but du traitement...")
logger.success("Op√©ration termin√©e avec succ√®s !")
logger.warning("Cette action est irr√©versible")
logger.error("√âchec de la connexion au d√©p√¥t")
logger.debug("D√©tails techniques: {...}")  # Affich√© seulement si DEBUG=1
Interactions utilisateur
Confirmations
# Confirmation avec valeur par d√©faut "oui"
if logger.confirm("Voulez-vous continuer?", default=True):
    print("L'utilisateur a confirm√©")

# Confirmation avec abort (quitte le programme si non)
logger.confirm("√ätes-vous s√ªr?", abort=True)  # Quitte si r√©ponse = non
Saisies utilisateur
# Saisie simple
nom = logger.prompt("Quel est votre nom?")

# Saisie avec valeur par d√©faut
version = logger.prompt("Num√©ro de version", default="1.0.0")

# Saisie de mot de passe (masqu√©)
mdp = logger.prompt("Mot de passe", password=True)
Mode non-interactif
En mode non-interactif (SilentLogger) :

Tous les messages sauf les erreurs sont ignor√©s
Les confirmations retournent toujours True (sauf si default=False)
Les prompts retournent la valeur par d√©faut ou une cha√Æne vide

logger = get_logger(non_interactive=True)
logger.info("Ce message ne sera pas affich√©")
result = logger.confirm("Cette question ne sera pas pos√©e")  # retourne True

Exemples complets
1. Script interactif
from logger import get_logger

def main():
    logger = get_logger()

    logger.info("Bienvenue dans l'assistant Git!")

    if not logger.confirm("Voulez-vous commencer?"):
        logger.warning("Op√©ration annul√©e")
        return

    message = logger.prompt("Message de commit")
    logger.info(f"Commit en cours avec le message: {message}")

    # Simulation d'une op√©ration
    logger.success("Op√©ration termin√©e!")

if __name__ == "__main__":
    main()
2. Script non-interactif
from logger import get_logger

def main():
    logger = get_logger(non_interactive=True)

    # En mode non-interactif, toutes les interactions ont des valeurs par d√©faut
    if logger.confirm("Voulez-vous continuer?", default=True):
        version = logger.prompt("Num√©ro de version", default="1.0.0")
        logger.info(f"Traitement de la version {version}...")  # Ne sera pas affich√©
        logger.success("Termin√©!")  # Ne sera pas affich√©

    logger.error("Cette erreur sera affich√©e m√™me en mode silencieux")

if __name__ == "__main__":
    main()
3. Utilisation avanc√©e avec gestion d'erreurs
from logger import get_logger

def safe_operation(logger):
    try:
        logger.info("D√©but de l'op√©ration...")
        # Simulation d'une erreur
        raise ValueError("Quelque chose s'est mal pass√©!")
    except Exception as e:
        logger.error(f"√âchec: {str(e)}")
        if logger.confirm("Voulez-vous r√©essayer?", default=False):
            safe_operation(logger)
        else:
            logger.warning("Op√©ration abandonn√©e")

def main():
    logger = get_logger()
    safe_operation(logger)

if __name__ == "__main__":
    main()

Personnalisation
1. Cr√©er un logger personnalis√©
from logger import Logger

class FileLogger:
    """Logger qui √©crit dans un fichier."""

    def __init__(self, log_file="app.log"):
        self.log_file = log_file

    def info(self, message: str, newline: bool = True):
        with open(self.log_file, "a") as f:
            f.write(f"[INFO] {message}\n")

    # Impl√©menter les autres m√©thodes de l'interface Logger...
    ...

# Utilisation
logger = FileLogger("mon_fichier.log")
logger.info("Test")
2. Surcharger les couleurs/ic√¥nes
from logger import ConsoleLogger

class MyCustomLogger(ConsoleLogger):
    def _format_message(self, icon, message, color):
        # Personnalisation des ic√¥nes/couleurs
        if "erreur" in message.lower():
            icon = "üí•"
            color = "\033[31m"  # Rouge
        return super()._format_message(icon, message, color)

logger = MyCustomLogger()
logger.error("Une erreur critique est survenue")  # Affiche üí• au lieu de ‚úó

Variables d'environnement



Variable
Description
Valeurs possibles



DEBUG
Active les messages de debug
1, true, yes


FORCE_COLOR
Force l'affichage des couleurs (m√™me si stdout n'est pas un TTY)
1, true, yes


NO_COLOR
D√©sactive compl√®tement les couleurs
Toute valeur


Exemple :
# Activer le mode debug
DEBUG=1 python mon_script.py

# Forcer les couleurs
FORCE_COLOR=1 python mon_script.py | grep "erreur"

Bonnes pratiques

Utiliser get_logger() plut√¥t que d'instancier directement les classes :
# ‚úÖ Bonne pratique
logger = get_logger(non_interactive=is_ci)

# ‚ùå √Ä √©viter
logger = ConsoleLogger()

G√©rer les modes interactif/non-interactif d√®s le d√©but du script :
def main():
    is_ci = os.environ.get("CI", "false").lower() in ("true", "1")
    logger = get_logger(non_interactive=is_ci)
    # ...

Utiliser les valeurs par d√©faut pour les prompts en mode non-interactif :
# ‚úÖ Bonne pratique
version = logger.prompt("Version", default="1.0.0")

# ‚ùå √Ä √©viter (plantera en mode non-interactif)
version = logger.prompt("Version")

R√©server logger.error() pour les erreurs critiques :
# ‚úÖ Pour les erreurs bloquantes
logger.error("Impossible de se connecter au d√©p√¥t")

# ‚ùå Pour les avertissements (utiliser warning √† la place)
logger.error("Attention, cette action est irr√©versible")

Utiliser newline=False pour les messages multi-lignes :
logger.info("Traitement en cours", newline=False)
for i in range(10):
    logger.info(f" {i}/10", newline=False)
logger.info(" termin√©", newline=True)

Documenter les interactions utilisateur dans les docstrings :
def dangerous_operation(logger):
    """Effectue une op√©ration dangereuse.

    Args:
        logger: Instance de Logger pour les interactions utilisateur.
            - Demande une confirmation avant de continuer.
            - Affiche un avertissement si l'op√©ration √©choue.
    """
    if not logger.confirm("Cette op√©ration est dangereuse. Continuer?", default=False):
        return
    # ...



R√©solution des probl√®mes
Probl√®me : Les couleurs ne s'affichent pas
Causes possibles :

La sortie standard n'est pas un TTY (ex : redirection vers un fichier)
La variable NO_COLOR est d√©finie
Le terminal ne supporte pas les couleurs ANSI

Solutions :

Forcer les couleurs avec FORCE_COLOR=1
Utiliser --color=always si votre script le supporte
V√©rifier la configuration du terminal


Probl√®me : Le script plante en mode non-interactif
Cause probable :
Vous utilisez logger.prompt() ou logger.confirm() sans valeur par d√©faut.
Solution :
Toujours fournir une valeur par d√©faut en mode non-interactif :
value = logger.prompt("Valeur", default="valeur_par_d√©faut")

Probl√®me : Les messages de debug n'apparaissent pas
Cause probable :
La variable d'environnement DEBUG n'est pas d√©finie.
Solution :
DEBUG=1 python mon_script.py

Changelog
v1.0.0 (2023-11-15)

Premi√®re version stable
Support complet des modes interactif/non-interactif
Gestion des couleurs et ic√¥nes
Interface Logger bien d√©finie

v1.1.0 (2023-11-20)

Ajout du support des mots de passe masqu√©s
Am√©lioration de la gestion des valeurs par d√©faut
Meilleure gestion des erreurs


---

## **3. Points cl√©s de l'impl√©mentation**
1. **Respect des standards** :
   - **Ruff/PEP 8** : Longueur de ligne (88 chars), nommage, typage
   - **Typage strict** : Utilisation de `Protocol` pour l'interface `Logger`
   - **Docstrings** : Format Google pour toutes les m√©thodes publiques

2. **Fonctionnalit√©s avanc√©es** :
   - **D√©tection automatique des couleurs** : D√©sactive les couleurs si `stdout` n'est pas un TTY
   - **Mode debug** : Contr√¥l√© par la variable d'environnement `DEBUG`
   - **Gestion des mots de passe** : Masquage de la saisie avec `getpass`
   - **Confirmations avec abort** : Permet de quitter le programme si l'utilisateur refuse

3. **Extensibilit√©** :
   - **Interface claire** : Toute nouvelle impl√©mentation n'a qu'√† respecter le `Protocol`
   - **Fabrique `get_logger()`** : Permet de changer facilement d'impl√©mentation
   - **Personnalisation** : Surcharge possible des ic√¥nes/couleurs

4. **Gestion des modes** :
   - **Interactif** : `ConsoleLogger` avec saisies utilisateur
   - **Non-interactif** : `SilentLogger` pour les scripts/CI
   - **Hybride** : Comportement adapt√© selon le contexte

5. **Robustesse** :
   - **Gestion des erreurs** : Messages d'erreur toujours affich√©s (m√™me en mode silencieux)
   - **Fallbacks** : Si `getpass` n'est pas disponible, utilise `input`
   - **Validation des saisies** : Gestion des valeurs par d√©faut et des confirmations

---

## **4. Exemple d'int√©gration dans le projet**
```python
# git_commands.py (extrait)
from logger import get_logger, Logger

def commit_and_push_workflow(logger: Logger, non_interactive: bool = False) -> None:
    """Effectue un commit et un push avec gestion des interactions."""
    logger.info("D√©but du workflow de commit/push")

    if non_interactive:
        message = logger.prompt(
            "Message de commit",
            default="Auto-commit from CI"
        )
    else:
        message = logger.prompt("Message de commit")
        if not logger.confirm("Confirmer le commit?"):
            logger.warning("Op√©ration annul√©e")
            return

    logger.info(f"Commit en cours avec le message: {message}")
    # ... (logique de commit/push)
    logger.success("Op√©ration termin√©e avec succ√®s!")