{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Git Scripts Documentation This documentation provides information about the Git utility scripts.","title":"Home"},{"location":"#welcome-to-git-scripts-documentation","text":"This documentation provides information about the Git utility scripts.","title":"Welcome to Git Scripts Documentation"},{"location":"CLI/","text":"Git Workflow Tool - Interface en Ligne de Commande Table des mati\u00e8res Introduction Installation Utilisation de base Options globales Commandes disponibles commit release sync tag Mode interactif Exemples d'utilisation Variables d'environnement Int\u00e9gration CI/CD D\u00e9veloppement et extension Introduction git_tools/cli.py est le point d'entr\u00e9e principal de Git Workflow Tool. Il offre : - Une interface en ligne de commande compl\u00e8te - Un menu interactif pour les utilisateurs d\u00e9butants - Un mode non-interactif pour les scripts et CI/CD - Une architecture modulaire facile \u00e0 \u00e9tendre Installation Via pip (recommand\u00e9) pip install git-tools En d\u00e9veloppement git clone https://github.com/votre-repo/git-tools.git cd git-tools pip install -e . Utilisation de base # Lancer le menu interactif git-tools # Ex\u00e9cuter une commande sp\u00e9cifique git-tools commit -m \"Mon message de commit\" # Afficher l'aide git-tools --help # Afficher la version git-tools --version Options globales Option Description --version Affiche la version et quitte --non-interactive D\u00e9sactive les prompts interactifs (pour les scripts/CI) --debug Active les messages de debug --force-color Force l'affichage des couleurs m\u00eame si stdout n'est pas un TTY --help Affiche l'aide et quitte Exemple : git-tools --non-interactive --debug commit -m \"Fix bug\" Commandes disponibles commit Effectue un commit et push vers le d\u00e9p\u00f4t distant. Usage : git-tools commit [OPTIONS] Options : Option Description -m , --message Message de commit (d\u00e9sactive le prompt) --amend Modifie le dernier commit au lieu d'en cr\u00e9er un nouveau Exemples : # Mode interactif git-tools commit # Mode non-interactif avec message git-tools --non-interactive commit -m \"Fix critical bug\" release Cr\u00e9e une nouvelle release (tag + push). Usage : git-tools release [OPTIONS] Options : Option Description --type Type de release (major/minor/patch) --dry-run Simule la cr\u00e9ation sans appliquer les changements Exemples : # Cr\u00e9er une release patch git-tools release --type patch # Simulation git-tools release --type minor --dry-run sync Synchronise le d\u00e9p\u00f4t local avec le d\u00e9p\u00f4t distant. Usage : git-tools sync Exemple : git-tools --non-interactive sync tag G\u00e8re les tags Git (liste, cr\u00e9ation, suppression). Usage : git-tools tag ACTION [OPTIONS] Actions disponibles : Action Description list Liste tous les tags create Cr\u00e9e un nouveau tag delete Supprime un tag existant Options : Option Description --name Nom du tag (pour create/delete) --message Message du tag (pour create) Exemples : # Lister les tags git-tools tag list # Cr\u00e9er un tag git-tools tag create --name v1.0.0 --message \"Version 1.0.0\" # Supprimer un tag git-tools tag delete --name v1.0.0 Mode interactif Si aucune commande n'est sp\u00e9cifi\u00e9e, l'outil lance un menu interactif : \ud83d\udc19 Git Workflow Tool - Menu Principal ================================================== 1. Commit & Push 2. Cr\u00e9er une Release 3. Synchroniser avec le d\u00e9p\u00f4t distant 4. G\u00e9rer les Tags 5. Quitter Navigation : - Utilisez les num\u00e9ros pour s\u00e9lectionner une option - Suivez les instructions \u00e0 l'\u00e9cran Exemple : git-tools # Lance le menu interactif Exemples d'utilisation 1. Workflow de commit complet # Mode interactif git-tools commit # Mode non-interactif (pour CI) git-tools --non-interactive commit -m \"Update README [skip ci]\" 2. Cr\u00e9ation d'une release # Avec confirmation interactive git-tools release --type minor # Sans interaction (pour scripts) git-tools --non-interactive release --type patch 3. Synchronisation # Mode interactif git-tools sync # Mode silencieux git-tools --non-interactive sync 4. Gestion des tags # Lister les tags git-tools tag list # Cr\u00e9er un tag annot\u00e9 git-tools tag create --name v2.0.0 --message \"Version 2.0.0\" # Supprimer un tag git-tools --non-interactive tag delete --name v2.0.0 Variables d'environnement Variable Description Valeurs possibles DEBUG Active les messages de debug 1 , true , yes FORCE_COLOR Force l'affichage des couleurs 1 , true , yes NO_COLOR D\u00e9sactive compl\u00e8tement les couleurs Toute valeur GIT_TOOLS_NON_INTERACTIVE D\u00e9sactive le mode interactif (alternative \u00e0 --non-interactive ) Toute valeur Exemple : DEBUG=1 git-tools commit Int\u00e9gration CI/CD Pour utiliser Git Workflow Tool dans vos pipelines CI/CD : GitHub Actions - name: Commit changes run: | git-tools --non-interactive commit -m \"Auto-commit from CI [skip ci]\" git-tools --non-interactive sync GitLab CI script: - git-tools --non-interactive release --type patch Jenkins sh 'git-tools --non-interactive --debug sync' D\u00e9veloppement et extension Ajouter une nouvelle commande Cr\u00e9er une fonction workflow dans git_tools/workflows.py : python def ma_nouvelle_commande(logger: Logger, args: argparse.Namespace) -> None: logger.info(\"Ex\u00e9cution de ma nouvelle commande...\") # ... logique m\u00e9tier Mettre \u00e0 jour COMMAND_MAPPING dans cli.py : python COMMAND_MAPPING = { # ... commandes existantes ... \"ma-commande\": ma_nouvelle_commande, } Ajouter le parser de commande dans parse_args() : python ma_commande_parser = subparsers.add_parser( \"ma-commande\", help=\"Description de ma commande\", ) ma_commande_parser.add_argument( \"--option\", help=\"Description de l'option\", ) Structure du projet git_tools/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 cli.py # Point d'entr\u00e9e (ce fichier) \u251c\u2500\u2500 logger.py # Gestion des logs et interactions \u251c\u2500\u2500 workflows.py # Logique m\u00e9tier des commandes \u2514\u2500\u2500 utils/ # Fonctions utilitaires Bonnes pratiques Toujours utiliser le logger pour les interactions utilisateur. G\u00e9rer les erreurs proprement . Documenter les nouvelles commandes dans le __doc__ du module. Respecter le typage pour une meilleure maintenabilit\u00e9. R\u00e9solution des probl\u00e8mes Probl\u00e8me : Commande non trouv\u00e9e Solutions : V\u00e9rifier COMMAND_MAPPING , le parser, et la casse. Probl\u00e8me : L'outil plante en mode non-interactif Solutions : V\u00e9rifier le flag --non-interactive , s'assurer que les prompt / confirm ont des valeurs par d\u00e9faut. Probl\u00e8me : Les couleurs ne s'affichent pas Solutions : Forcer avec --force-color , v\u00e9rifier NO_COLOR . Probl\u00e8me : Erreur de permission Solutions : Configurer la cl\u00e9 SSH avec ssh-add , utiliser le workflow de setup SSH. Changelog v1.0.0 (2023-11-20): Premi\u00e8re version stable. v1.1.0 (2023-11-25): Ajout du support des variables d'environnement. Licence Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus de d\u00e9tails.","title":"CLI"},{"location":"CLI/#git-workflow-tool-interface-en-ligne-de-commande","text":"","title":"Git Workflow Tool - Interface en Ligne de Commande"},{"location":"CLI/#table-des-matieres","text":"Introduction Installation Utilisation de base Options globales Commandes disponibles commit release sync tag Mode interactif Exemples d'utilisation Variables d'environnement Int\u00e9gration CI/CD D\u00e9veloppement et extension","title":"Table des mati\u00e8res"},{"location":"CLI/#introduction","text":"git_tools/cli.py est le point d'entr\u00e9e principal de Git Workflow Tool. Il offre : - Une interface en ligne de commande compl\u00e8te - Un menu interactif pour les utilisateurs d\u00e9butants - Un mode non-interactif pour les scripts et CI/CD - Une architecture modulaire facile \u00e0 \u00e9tendre","title":"Introduction"},{"location":"CLI/#installation","text":"","title":"Installation"},{"location":"CLI/#via-pip-recommande","text":"pip install git-tools","title":"Via pip (recommand\u00e9)"},{"location":"CLI/#en-developpement","text":"git clone https://github.com/votre-repo/git-tools.git cd git-tools pip install -e .","title":"En d\u00e9veloppement"},{"location":"CLI/#utilisation-de-base","text":"# Lancer le menu interactif git-tools # Ex\u00e9cuter une commande sp\u00e9cifique git-tools commit -m \"Mon message de commit\" # Afficher l'aide git-tools --help # Afficher la version git-tools --version","title":"Utilisation de base"},{"location":"CLI/#options-globales","text":"Option Description --version Affiche la version et quitte --non-interactive D\u00e9sactive les prompts interactifs (pour les scripts/CI) --debug Active les messages de debug --force-color Force l'affichage des couleurs m\u00eame si stdout n'est pas un TTY --help Affiche l'aide et quitte Exemple : git-tools --non-interactive --debug commit -m \"Fix bug\"","title":"Options globales"},{"location":"CLI/#commandes-disponibles","text":"","title":"Commandes disponibles"},{"location":"CLI/#commit","text":"Effectue un commit et push vers le d\u00e9p\u00f4t distant. Usage : git-tools commit [OPTIONS] Options : Option Description -m , --message Message de commit (d\u00e9sactive le prompt) --amend Modifie le dernier commit au lieu d'en cr\u00e9er un nouveau Exemples : # Mode interactif git-tools commit # Mode non-interactif avec message git-tools --non-interactive commit -m \"Fix critical bug\"","title":"commit"},{"location":"CLI/#release","text":"Cr\u00e9e une nouvelle release (tag + push). Usage : git-tools release [OPTIONS] Options : Option Description --type Type de release (major/minor/patch) --dry-run Simule la cr\u00e9ation sans appliquer les changements Exemples : # Cr\u00e9er une release patch git-tools release --type patch # Simulation git-tools release --type minor --dry-run","title":"release"},{"location":"CLI/#sync","text":"Synchronise le d\u00e9p\u00f4t local avec le d\u00e9p\u00f4t distant. Usage : git-tools sync Exemple : git-tools --non-interactive sync","title":"sync"},{"location":"CLI/#tag","text":"G\u00e8re les tags Git (liste, cr\u00e9ation, suppression). Usage : git-tools tag ACTION [OPTIONS] Actions disponibles : Action Description list Liste tous les tags create Cr\u00e9e un nouveau tag delete Supprime un tag existant Options : Option Description --name Nom du tag (pour create/delete) --message Message du tag (pour create) Exemples : # Lister les tags git-tools tag list # Cr\u00e9er un tag git-tools tag create --name v1.0.0 --message \"Version 1.0.0\" # Supprimer un tag git-tools tag delete --name v1.0.0","title":"tag"},{"location":"CLI/#mode-interactif","text":"Si aucune commande n'est sp\u00e9cifi\u00e9e, l'outil lance un menu interactif : \ud83d\udc19 Git Workflow Tool - Menu Principal ================================================== 1. Commit & Push 2. Cr\u00e9er une Release 3. Synchroniser avec le d\u00e9p\u00f4t distant 4. G\u00e9rer les Tags 5. Quitter Navigation : - Utilisez les num\u00e9ros pour s\u00e9lectionner une option - Suivez les instructions \u00e0 l'\u00e9cran Exemple : git-tools # Lance le menu interactif","title":"Mode interactif"},{"location":"CLI/#exemples-dutilisation","text":"","title":"Exemples d'utilisation"},{"location":"CLI/#1-workflow-de-commit-complet","text":"# Mode interactif git-tools commit # Mode non-interactif (pour CI) git-tools --non-interactive commit -m \"Update README [skip ci]\"","title":"1. Workflow de commit complet"},{"location":"CLI/#2-creation-dune-release","text":"# Avec confirmation interactive git-tools release --type minor # Sans interaction (pour scripts) git-tools --non-interactive release --type patch","title":"2. Cr\u00e9ation d'une release"},{"location":"CLI/#3-synchronisation","text":"# Mode interactif git-tools sync # Mode silencieux git-tools --non-interactive sync","title":"3. Synchronisation"},{"location":"CLI/#4-gestion-des-tags","text":"# Lister les tags git-tools tag list # Cr\u00e9er un tag annot\u00e9 git-tools tag create --name v2.0.0 --message \"Version 2.0.0\" # Supprimer un tag git-tools --non-interactive tag delete --name v2.0.0","title":"4. Gestion des tags"},{"location":"CLI/#variables-denvironnement","text":"Variable Description Valeurs possibles DEBUG Active les messages de debug 1 , true , yes FORCE_COLOR Force l'affichage des couleurs 1 , true , yes NO_COLOR D\u00e9sactive compl\u00e8tement les couleurs Toute valeur GIT_TOOLS_NON_INTERACTIVE D\u00e9sactive le mode interactif (alternative \u00e0 --non-interactive ) Toute valeur Exemple : DEBUG=1 git-tools commit","title":"Variables d'environnement"},{"location":"CLI/#integration-cicd","text":"Pour utiliser Git Workflow Tool dans vos pipelines CI/CD :","title":"Int\u00e9gration CI/CD"},{"location":"CLI/#github-actions","text":"- name: Commit changes run: | git-tools --non-interactive commit -m \"Auto-commit from CI [skip ci]\" git-tools --non-interactive sync","title":"GitHub Actions"},{"location":"CLI/#gitlab-ci","text":"script: - git-tools --non-interactive release --type patch","title":"GitLab CI"},{"location":"CLI/#jenkins","text":"sh 'git-tools --non-interactive --debug sync'","title":"Jenkins"},{"location":"CLI/#developpement-et-extension","text":"","title":"D\u00e9veloppement et extension"},{"location":"CLI/#ajouter-une-nouvelle-commande","text":"Cr\u00e9er une fonction workflow dans git_tools/workflows.py : python def ma_nouvelle_commande(logger: Logger, args: argparse.Namespace) -> None: logger.info(\"Ex\u00e9cution de ma nouvelle commande...\") # ... logique m\u00e9tier Mettre \u00e0 jour COMMAND_MAPPING dans cli.py : python COMMAND_MAPPING = { # ... commandes existantes ... \"ma-commande\": ma_nouvelle_commande, } Ajouter le parser de commande dans parse_args() : python ma_commande_parser = subparsers.add_parser( \"ma-commande\", help=\"Description de ma commande\", ) ma_commande_parser.add_argument( \"--option\", help=\"Description de l'option\", )","title":"Ajouter une nouvelle commande"},{"location":"CLI/#structure-du-projet","text":"git_tools/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 cli.py # Point d'entr\u00e9e (ce fichier) \u251c\u2500\u2500 logger.py # Gestion des logs et interactions \u251c\u2500\u2500 workflows.py # Logique m\u00e9tier des commandes \u2514\u2500\u2500 utils/ # Fonctions utilitaires","title":"Structure du projet"},{"location":"CLI/#bonnes-pratiques","text":"Toujours utiliser le logger pour les interactions utilisateur. G\u00e9rer les erreurs proprement . Documenter les nouvelles commandes dans le __doc__ du module. Respecter le typage pour une meilleure maintenabilit\u00e9.","title":"Bonnes pratiques"},{"location":"CLI/#resolution-des-problemes","text":"Probl\u00e8me : Commande non trouv\u00e9e Solutions : V\u00e9rifier COMMAND_MAPPING , le parser, et la casse. Probl\u00e8me : L'outil plante en mode non-interactif Solutions : V\u00e9rifier le flag --non-interactive , s'assurer que les prompt / confirm ont des valeurs par d\u00e9faut. Probl\u00e8me : Les couleurs ne s'affichent pas Solutions : Forcer avec --force-color , v\u00e9rifier NO_COLOR . Probl\u00e8me : Erreur de permission Solutions : Configurer la cl\u00e9 SSH avec ssh-add , utiliser le workflow de setup SSH.","title":"R\u00e9solution des probl\u00e8mes"},{"location":"CLI/#changelog","text":"v1.0.0 (2023-11-20): Premi\u00e8re version stable. v1.1.0 (2023-11-25): Ajout du support des variables d'environnement.","title":"Changelog"},{"location":"CLI/#licence","text":"Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus de d\u00e9tails.","title":"Licence"},{"location":"LOGGER/","text":"Git Workflow Tool - Logger Module Table des mati\u00e8res Introduction Installation Concepts cl\u00e9s Utilisation Initialisation Affichage de messages Interactions utilisateur Mode non-interactif Exemples complets Personnalisation Variables d'environnement Bonnes pratiques Introduction Le module logger.py fournit une interface unifi\u00e9e pour : - G\u00e9rer les sorties utilisateur (messages, erreurs, succ\u00e8s, avertissements) - Interagir avec l'utilisateur (confirmations, saisies) - Supporter les modes interactif/non-interactif - G\u00e9rer le debugging via une variable d'environnement Il est con\u00e7u pour \u00eatre : \u2705 Testable (mockable facilement) \u2705 Extensible (nouveaux types de loggers) \u2705 Consistant (messages format\u00e9s de mani\u00e8re uniforme) \u2705 Flexible (comportements non-interactifs) Installation Le module est inclus dans le package principal. Aucune installation suppl\u00e9mentaire n'est n\u00e9cessaire. Concepts cl\u00e9s 1. L'interface Logger D\u00e9finit le contrat que doivent respecter tous les loggers : class Logger(Protocol): def info(self, message: str, newline: bool = True) -> None: ... def success(self, message: str, newline: bool = True) -> None: ... # ... (autres m\u00e9thodes) 2. Impl\u00e9mentations disponibles Classe Description ConsoleLogger Affiche des messages coloris\u00e9s en console (mode interactif par d\u00e9faut) SilentLogger Ignore la plupart des messages (pour les scripts non-interactifs) 3. Niveaux de messages M\u00e9thode Ic\u00f4ne Couleur Utilisation typique info() \u2139 Bleu Messages informatifs success() \u2713 Vert Op\u00e9rations r\u00e9ussies warning() \u26a0 Jaune Avertissements error() \u2717 Rouge Erreurs (affich\u00e9es sur stderr) debug() \ud83d\udc1b Violet Messages de debug (si DEBUG=1 ) Utilisation Initialisation from logger import get_logger # Mode interactif (par d\u00e9faut) logger = get_logger() # Mode non-interactif (silencieux) logger = get_logger(non_interactive=True) # Forcer les couleurs (m\u00eame si stdout n'est pas un TTY) logger = get_logger(force_color=True) Affichage de messages logger.info(\"D\u00e9but du traitement...\") logger.success(\"Op\u00e9ration termin\u00e9e avec succ\u00e8s !\") logger.warning(\"Cette action est irr\u00e9versible\") logger.error(\"\u00c9chec de la connexion au d\u00e9p\u00f4t\") logger.debug(\"D\u00e9tails techniques: {...}\") # Affich\u00e9 seulement si DEBUG=1 Interactions utilisateur Confirmations # Confirmation avec valeur par d\u00e9faut \"oui\" if logger.confirm(\"Voulez-vous continuer?\", default=True): print(\"L'utilisateur a confirm\u00e9\") # Confirmation avec abort (quitte le programme si non) logger.confirm(\"\u00cates-vous s\u00fbr?\", abort=True) # Quitte si r\u00e9ponse = non Saisies utilisateur # Saisie simple nom = logger.prompt(\"Quel est votre nom?\") # Saisie avec valeur par d\u00e9faut version = logger.prompt(\"Num\u00e9ro de version\", default=\"1.0.0\") # Saisie de mot de passe (masqu\u00e9) mdp = logger.prompt(\"Mot de passe\", password=True) Mode non-interactif En mode non-interactif ( SilentLogger ) : - Tous les messages sauf les erreurs sont ignor\u00e9s - Les confirmations retournent toujours True (sauf si default=False ) - Les prompts retournent la valeur par d\u00e9faut ou une cha\u00eene vide logger = get_logger(non_interactive=True) logger.info(\"Ce message ne sera pas affich\u00e9\") result = logger.confirm(\"Cette question ne sera pas pos\u00e9e\") # retourne True Exemples complets 1. Script interactif from logger import get_logger def main(): logger = get_logger() logger.info(\"Bienvenue dans l'assistant Git!\") if not logger.confirm(\"Voulez-vous commencer?\"): logger.warning(\"Op\u00e9ration annul\u00e9e\") return message = logger.prompt(\"Message de commit\") logger.info(f\"Commit en cours avec le message: {message}\") # Simulation d'une op\u00e9ration logger.success(\"Op\u00e9ration termin\u00e9e!\") if __name__ == \"__main__\": main() 2. Script non-interactif from logger import get_logger def main(): logger = get_logger(non_interactive=True) # En mode non-interactif, toutes les interactions ont des valeurs par d\u00e9faut if logger.confirm(\"Voulez-vous continuer?\", default=True): version = logger.prompt(\"Num\u00e9ro de version\", default=\"1.0.0\") logger.info(f\"Traitement de la version {version}...\") # Ne sera pas affich\u00e9 logger.success(\"Termin\u00e9!\") # Ne sera pas affich\u00e9 logger.error(\"Cette erreur sera affich\u00e9e m\u00eame en mode silencieux\") if __name__ == \"__main__\": main() 3. Utilisation avanc\u00e9e avec gestion d'erreurs from logger import get_logger def safe_operation(logger): try: logger.info(\"D\u00e9but de l'op\u00e9ration...\") # Simulation d'une erreur raise ValueError(\"Quelque chose s'est mal pass\u00e9!\") except Exception as e: logger.error(f\"\u00c9chec: {str(e)}\") if logger.confirm(\"Voulez-vous r\u00e9essayer?\", default=False): safe_operation(logger) else: logger.warning(\"Op\u00e9ration abandonn\u00e9e\") def main(): logger = get_logger() safe_operation(logger) if __name__ == \"__main__\": main() Personnalisation 1. Cr\u00e9er un logger personnalis\u00e9 from logger import Logger class FileLogger: \"\"\"Logger qui \u00e9crit dans un fichier.\"\"\" def __init__(self, log_file=\"app.log\"): self.log_file = log_file def info(self, message: str, newline: bool = True): with open(self.log_file, \"a\") as f: f.write(f\"[INFO] {message}\\n\") # Impl\u00e9menter les autres m\u00e9thodes de l'interface Logger... ... # Utilisation logger = FileLogger(\"mon_fichier.log\") logger.info(\"Test\") 2. Surcharger les couleurs/ic\u00f4nes from logger import ConsoleLogger class MyCustomLogger(ConsoleLogger): def _format_message(self, icon, message, color): # Personnalisation des ic\u00f4nes/couleurs if \"erreur\" in message.lower(): icon = \"\ud83d\udca5\" color = \"\\033[31m\" # Rouge return super()._format_message(icon, message, color) logger = MyCustomLogger() logger.error(\"Une erreur critique est survenue\") # Affiche \ud83d\udca5 au lieu de \u2717 Variables d'environnement Variable Description Valeurs possibles DEBUG Active les messages de debug 1 , true , yes FORCE_COLOR Force l'affichage des couleurs (m\u00eame si stdout n'est pas un TTY) 1 , true , yes NO_COLOR D\u00e9sactive compl\u00e8tement les couleurs Toute valeur Exemple : # Activer le mode debug DEBUG=1 python mon_script.py # Forcer les couleurs FORCE_COLOR=1 python mon_script.py | grep \"erreur\" Bonnes pratiques Utiliser get_logger() plut\u00f4t que d'instancier directement les classes. G\u00e9rer les modes interactif/non-interactif d\u00e8s le d\u00e9but du script. Utiliser les valeurs par d\u00e9faut pour les prompts en mode non-interactif. R\u00e9server logger.error() pour les erreurs critiques. Utiliser newline=False pour les messages sur la m\u00eame ligne. Documenter les interactions utilisateur dans les docstrings. R\u00e9solution des probl\u00e8mes Probl\u00e8me : Les couleurs ne s'affichent pas Causes : Sortie non-TTY, variable NO_COLOR , terminal incompatible. Solutions : Forcer avec FORCE_COLOR=1 , v\u00e9rifier la configuration. Probl\u00e8me : Le script plante en mode non-interactif Cause : prompt() ou confirm() sans valeur par d\u00e9faut. Solution : Toujours fournir une valeur par d\u00e9faut. Probl\u00e8me : Les messages de debug n'apparaissent pas Cause : Variable DEBUG non d\u00e9finie. Solution : Lancer avec DEBUG=1 . Changelog v1.0.0 (2023-11-15): Premi\u00e8re version stable. v1.1.0 (2023-11-20): Ajout du support des mots de passe masqu\u00e9s.","title":"Logger"},{"location":"LOGGER/#git-workflow-tool-logger-module","text":"","title":"Git Workflow Tool - Logger Module"},{"location":"LOGGER/#table-des-matieres","text":"Introduction Installation Concepts cl\u00e9s Utilisation Initialisation Affichage de messages Interactions utilisateur Mode non-interactif Exemples complets Personnalisation Variables d'environnement Bonnes pratiques","title":"Table des mati\u00e8res"},{"location":"LOGGER/#introduction","text":"Le module logger.py fournit une interface unifi\u00e9e pour : - G\u00e9rer les sorties utilisateur (messages, erreurs, succ\u00e8s, avertissements) - Interagir avec l'utilisateur (confirmations, saisies) - Supporter les modes interactif/non-interactif - G\u00e9rer le debugging via une variable d'environnement Il est con\u00e7u pour \u00eatre : \u2705 Testable (mockable facilement) \u2705 Extensible (nouveaux types de loggers) \u2705 Consistant (messages format\u00e9s de mani\u00e8re uniforme) \u2705 Flexible (comportements non-interactifs)","title":"Introduction"},{"location":"LOGGER/#installation","text":"Le module est inclus dans le package principal. Aucune installation suppl\u00e9mentaire n'est n\u00e9cessaire.","title":"Installation"},{"location":"LOGGER/#concepts-cles","text":"","title":"Concepts cl\u00e9s"},{"location":"LOGGER/#1-linterface-logger","text":"D\u00e9finit le contrat que doivent respecter tous les loggers : class Logger(Protocol): def info(self, message: str, newline: bool = True) -> None: ... def success(self, message: str, newline: bool = True) -> None: ... # ... (autres m\u00e9thodes)","title":"1. L'interface Logger"},{"location":"LOGGER/#2-implementations-disponibles","text":"Classe Description ConsoleLogger Affiche des messages coloris\u00e9s en console (mode interactif par d\u00e9faut) SilentLogger Ignore la plupart des messages (pour les scripts non-interactifs)","title":"2. Impl\u00e9mentations disponibles"},{"location":"LOGGER/#3-niveaux-de-messages","text":"M\u00e9thode Ic\u00f4ne Couleur Utilisation typique info() \u2139 Bleu Messages informatifs success() \u2713 Vert Op\u00e9rations r\u00e9ussies warning() \u26a0 Jaune Avertissements error() \u2717 Rouge Erreurs (affich\u00e9es sur stderr) debug() \ud83d\udc1b Violet Messages de debug (si DEBUG=1 )","title":"3. Niveaux de messages"},{"location":"LOGGER/#utilisation","text":"","title":"Utilisation"},{"location":"LOGGER/#initialisation","text":"from logger import get_logger # Mode interactif (par d\u00e9faut) logger = get_logger() # Mode non-interactif (silencieux) logger = get_logger(non_interactive=True) # Forcer les couleurs (m\u00eame si stdout n'est pas un TTY) logger = get_logger(force_color=True)","title":"Initialisation"},{"location":"LOGGER/#affichage-de-messages","text":"logger.info(\"D\u00e9but du traitement...\") logger.success(\"Op\u00e9ration termin\u00e9e avec succ\u00e8s !\") logger.warning(\"Cette action est irr\u00e9versible\") logger.error(\"\u00c9chec de la connexion au d\u00e9p\u00f4t\") logger.debug(\"D\u00e9tails techniques: {...}\") # Affich\u00e9 seulement si DEBUG=1","title":"Affichage de messages"},{"location":"LOGGER/#interactions-utilisateur","text":"","title":"Interactions utilisateur"},{"location":"LOGGER/#confirmations","text":"# Confirmation avec valeur par d\u00e9faut \"oui\" if logger.confirm(\"Voulez-vous continuer?\", default=True): print(\"L'utilisateur a confirm\u00e9\") # Confirmation avec abort (quitte le programme si non) logger.confirm(\"\u00cates-vous s\u00fbr?\", abort=True) # Quitte si r\u00e9ponse = non","title":"Confirmations"},{"location":"LOGGER/#saisies-utilisateur","text":"# Saisie simple nom = logger.prompt(\"Quel est votre nom?\") # Saisie avec valeur par d\u00e9faut version = logger.prompt(\"Num\u00e9ro de version\", default=\"1.0.0\") # Saisie de mot de passe (masqu\u00e9) mdp = logger.prompt(\"Mot de passe\", password=True)","title":"Saisies utilisateur"},{"location":"LOGGER/#mode-non-interactif","text":"En mode non-interactif ( SilentLogger ) : - Tous les messages sauf les erreurs sont ignor\u00e9s - Les confirmations retournent toujours True (sauf si default=False ) - Les prompts retournent la valeur par d\u00e9faut ou une cha\u00eene vide logger = get_logger(non_interactive=True) logger.info(\"Ce message ne sera pas affich\u00e9\") result = logger.confirm(\"Cette question ne sera pas pos\u00e9e\") # retourne True","title":"Mode non-interactif"},{"location":"LOGGER/#exemples-complets","text":"","title":"Exemples complets"},{"location":"LOGGER/#1-script-interactif","text":"from logger import get_logger def main(): logger = get_logger() logger.info(\"Bienvenue dans l'assistant Git!\") if not logger.confirm(\"Voulez-vous commencer?\"): logger.warning(\"Op\u00e9ration annul\u00e9e\") return message = logger.prompt(\"Message de commit\") logger.info(f\"Commit en cours avec le message: {message}\") # Simulation d'une op\u00e9ration logger.success(\"Op\u00e9ration termin\u00e9e!\") if __name__ == \"__main__\": main()","title":"1. Script interactif"},{"location":"LOGGER/#2-script-non-interactif","text":"from logger import get_logger def main(): logger = get_logger(non_interactive=True) # En mode non-interactif, toutes les interactions ont des valeurs par d\u00e9faut if logger.confirm(\"Voulez-vous continuer?\", default=True): version = logger.prompt(\"Num\u00e9ro de version\", default=\"1.0.0\") logger.info(f\"Traitement de la version {version}...\") # Ne sera pas affich\u00e9 logger.success(\"Termin\u00e9!\") # Ne sera pas affich\u00e9 logger.error(\"Cette erreur sera affich\u00e9e m\u00eame en mode silencieux\") if __name__ == \"__main__\": main()","title":"2. Script non-interactif"},{"location":"LOGGER/#3-utilisation-avancee-avec-gestion-derreurs","text":"from logger import get_logger def safe_operation(logger): try: logger.info(\"D\u00e9but de l'op\u00e9ration...\") # Simulation d'une erreur raise ValueError(\"Quelque chose s'est mal pass\u00e9!\") except Exception as e: logger.error(f\"\u00c9chec: {str(e)}\") if logger.confirm(\"Voulez-vous r\u00e9essayer?\", default=False): safe_operation(logger) else: logger.warning(\"Op\u00e9ration abandonn\u00e9e\") def main(): logger = get_logger() safe_operation(logger) if __name__ == \"__main__\": main()","title":"3. Utilisation avanc\u00e9e avec gestion d'erreurs"},{"location":"LOGGER/#personnalisation","text":"","title":"Personnalisation"},{"location":"LOGGER/#1-creer-un-logger-personnalise","text":"from logger import Logger class FileLogger: \"\"\"Logger qui \u00e9crit dans un fichier.\"\"\" def __init__(self, log_file=\"app.log\"): self.log_file = log_file def info(self, message: str, newline: bool = True): with open(self.log_file, \"a\") as f: f.write(f\"[INFO] {message}\\n\") # Impl\u00e9menter les autres m\u00e9thodes de l'interface Logger... ... # Utilisation logger = FileLogger(\"mon_fichier.log\") logger.info(\"Test\")","title":"1. Cr\u00e9er un logger personnalis\u00e9"},{"location":"LOGGER/#2-surcharger-les-couleursicones","text":"from logger import ConsoleLogger class MyCustomLogger(ConsoleLogger): def _format_message(self, icon, message, color): # Personnalisation des ic\u00f4nes/couleurs if \"erreur\" in message.lower(): icon = \"\ud83d\udca5\" color = \"\\033[31m\" # Rouge return super()._format_message(icon, message, color) logger = MyCustomLogger() logger.error(\"Une erreur critique est survenue\") # Affiche \ud83d\udca5 au lieu de \u2717","title":"2. Surcharger les couleurs/ic\u00f4nes"},{"location":"LOGGER/#variables-denvironnement","text":"Variable Description Valeurs possibles DEBUG Active les messages de debug 1 , true , yes FORCE_COLOR Force l'affichage des couleurs (m\u00eame si stdout n'est pas un TTY) 1 , true , yes NO_COLOR D\u00e9sactive compl\u00e8tement les couleurs Toute valeur Exemple : # Activer le mode debug DEBUG=1 python mon_script.py # Forcer les couleurs FORCE_COLOR=1 python mon_script.py | grep \"erreur\"","title":"Variables d'environnement"},{"location":"LOGGER/#bonnes-pratiques","text":"Utiliser get_logger() plut\u00f4t que d'instancier directement les classes. G\u00e9rer les modes interactif/non-interactif d\u00e8s le d\u00e9but du script. Utiliser les valeurs par d\u00e9faut pour les prompts en mode non-interactif. R\u00e9server logger.error() pour les erreurs critiques. Utiliser newline=False pour les messages sur la m\u00eame ligne. Documenter les interactions utilisateur dans les docstrings.","title":"Bonnes pratiques"},{"location":"LOGGER/#resolution-des-problemes","text":"Probl\u00e8me : Les couleurs ne s'affichent pas Causes : Sortie non-TTY, variable NO_COLOR , terminal incompatible. Solutions : Forcer avec FORCE_COLOR=1 , v\u00e9rifier la configuration. Probl\u00e8me : Le script plante en mode non-interactif Cause : prompt() ou confirm() sans valeur par d\u00e9faut. Solution : Toujours fournir une valeur par d\u00e9faut. Probl\u00e8me : Les messages de debug n'apparaissent pas Cause : Variable DEBUG non d\u00e9finie. Solution : Lancer avec DEBUG=1 .","title":"R\u00e9solution des probl\u00e8mes"},{"location":"LOGGER/#changelog","text":"v1.0.0 (2023-11-15): Premi\u00e8re version stable. v1.1.0 (2023-11-20): Ajout du support des mots de passe masqu\u00e9s.","title":"Changelog"},{"location":"agent_capabilities/","text":"Agent Capabilities and Available Tools This document outlines the tools and capabilities available to the agent, along with best practices for their use. Understanding these tools is crucial for efficient and effective development, avoiding redundant work, and leveraging existing functionalities. Core Principles Leverage Existing Tools: Before attempting to re-develop any functionality, check if an existing tool or capability already provides it. Understand Tool Limitations: Be aware of the specific limitations and nuances of each tool (e.g., the strictness of the replace tool). Prioritize Safety and Efficiency: Use tools in a manner that ensures the safety of the codebase and the efficiency of the development process. Available Tools The agent has access to a set of powerful tools to interact with the filesystem, execute shell commands, perform web searches, and manage memory. These tools are exposed via the default_api . 1. Filesystem Interaction default_api.list_directory(path, file_filtering_options, ignore) Purpose: Lists files and subdirectories within a specified path. Best Practices: Always use absolute paths. Can filter using glob patterns and respect .gitignore . Example: default_api.list_directory(path='/path/to/project', ignore=['*.log']) default_api.read_file(absolute_path, limit, offset) Purpose: Reads the content of a specified file. Supports text, images, and PDF files. Best Practices: Always use absolute paths. Crucial for understanding file content before modification. For large text files, use limit and offset for pagination. Example: default_api.read_file(absolute_path='/path/to/file.txt') default_api.read_many_files(paths, exclude, file_filtering_options, include, recursive, useDefaultExcludes) Purpose: Reads content from multiple files specified by paths or glob patterns. Useful for gaining context from multiple files simultaneously. Best Practices: Use when a broad understanding of multiple files is needed. Supports glob patterns and exclusions. Example: default_api.read_many_files(paths=['src/**/*.py', 'docs/*.md']) default_api.search_file_content(pattern, include, path) Purpose: Searches for a regular expression pattern within file contents. Best Practices: Efficient for finding specific code snippets or patterns across the codebase. Can filter by glob patterns. Example: default_api.search_file_content(pattern='function\\s+myFunction', include='*.js') default_api.write_file(content, file_path) Purpose: Writes content to a specified file. Best Practices: Always use absolute paths. Use with caution as it overwrites existing content. Ensure content is correctly formatted and encoded. Example: default_api.write_file(content='Hello World', file_path='/path/to/new_file.txt') default_api.replace(file_path, new_string, old_string, expected_replacements) Purpose: Replaces text within a file. Best Practices: Highly sensitive to exact string matching. Always read_file the target content immediately before using replace to construct old_string precisely. For complex, multi-line, or uncertain changes, prefer the fallback method: read_file -> modify in memory -> write_file . Avoid escaping old_string or new_string unless explicitly required by the underlying system. Example: default_api.replace(file_path='/file.txt', old_string='old text', new_string='new text') default_api.glob(pattern, case_sensitive, path, respect_git_ignore) Purpose: Finds files matching specific glob patterns. Best Practices: Efficient for locating files by name or path structure. Can respect .gitignore . Example: default_api.glob(pattern='**/*.py') 2. Shell Command Execution default_api.run_shell_command(command, description, directory) Purpose: Executes a given shell command. Best Practices: Provide a clear description for commands that modify the filesystem or system state. Use & for background processes. Avoid interactive commands. Ensure commands are safe and necessary. Example: default_api.run_shell_command(command='ls -l', description='List files in current directory.') 3. Web Interaction default_api.web_fetch(prompt) Purpose: Processes content from URLs (including local/private network) based on instructions in the prompt. Best Practices: Include clear instructions and up to 20 URLs. Useful for summarizing web content or extracting specific data. Example: default_api.web_fetch(prompt='Summarize https://example.com/article') default_api.google_web_search(query) Purpose: Performs a web search using Google Search. Best Practices: Use for finding general information on the internet. Example: default_api.google_web_search(query='Python best practices') 4. Memory Management default_api.save_memory(fact) Purpose: Saves a specific piece of information or fact to long-term memory. Best Practices: Use only for user-specific facts or preferences that should persist across sessions. Do not use for conversational context or general project information. Example: default_api.save_memory(fact='User prefers tabs over spaces.') Common Workflows and Best Practices Code Modification: Always read_file before replace . For complex changes, use read_file -> in-memory modification -> write_file as a robust fallback. Git Operations: Use run_shell_command for git status , git add , git commit , git push , etc. Always check git status before committing. Python Development: Leverage run_shell_command for pip install , poetry install , pytest , ruff check , black , etc. Always work within virtual environments. Problem Solving: Use search_file_content and glob to understand the codebase. Use google_web_search for external knowledge. 5. Orchestration of External Python Development Tools The agent is capable of orchestrating a wide range of external Python development tools by executing them via default_api.run_shell_command . This allows the agent to leverage industry-standard tools for various development tasks. Formatage de Code : Black, Autopep8 Linting : Pylint, Flake8, Ruff Gestion des D\u00e9pendances : Pipenv, Poetry Tests : Pytest, Unittest Environnements Virtuels : Virtualenv, Conda Documentation : Sphinx, MkDocs Gestion de Version : Git, GitPython Construction et D\u00e9ploiement : Setuptools, Twine Profiling et Performance : cProfile, Py-Spy Gestion des Erreurs et Logging : Logging, Sentry Gestion des Donn\u00e9es : Pandas, SQLAlchemy S\u00e9curit\u00e9 : Bandit, Safety This document will be updated as new tools and capabilities are introduced or refined.","title":"Agent Capabilities"},{"location":"agent_capabilities/#agent-capabilities-and-available-tools","text":"This document outlines the tools and capabilities available to the agent, along with best practices for their use. Understanding these tools is crucial for efficient and effective development, avoiding redundant work, and leveraging existing functionalities.","title":"Agent Capabilities and Available Tools"},{"location":"agent_capabilities/#core-principles","text":"Leverage Existing Tools: Before attempting to re-develop any functionality, check if an existing tool or capability already provides it. Understand Tool Limitations: Be aware of the specific limitations and nuances of each tool (e.g., the strictness of the replace tool). Prioritize Safety and Efficiency: Use tools in a manner that ensures the safety of the codebase and the efficiency of the development process.","title":"Core Principles"},{"location":"agent_capabilities/#available-tools","text":"The agent has access to a set of powerful tools to interact with the filesystem, execute shell commands, perform web searches, and manage memory. These tools are exposed via the default_api .","title":"Available Tools"},{"location":"agent_capabilities/#1-filesystem-interaction","text":"default_api.list_directory(path, file_filtering_options, ignore) Purpose: Lists files and subdirectories within a specified path. Best Practices: Always use absolute paths. Can filter using glob patterns and respect .gitignore . Example: default_api.list_directory(path='/path/to/project', ignore=['*.log']) default_api.read_file(absolute_path, limit, offset) Purpose: Reads the content of a specified file. Supports text, images, and PDF files. Best Practices: Always use absolute paths. Crucial for understanding file content before modification. For large text files, use limit and offset for pagination. Example: default_api.read_file(absolute_path='/path/to/file.txt') default_api.read_many_files(paths, exclude, file_filtering_options, include, recursive, useDefaultExcludes) Purpose: Reads content from multiple files specified by paths or glob patterns. Useful for gaining context from multiple files simultaneously. Best Practices: Use when a broad understanding of multiple files is needed. Supports glob patterns and exclusions. Example: default_api.read_many_files(paths=['src/**/*.py', 'docs/*.md']) default_api.search_file_content(pattern, include, path) Purpose: Searches for a regular expression pattern within file contents. Best Practices: Efficient for finding specific code snippets or patterns across the codebase. Can filter by glob patterns. Example: default_api.search_file_content(pattern='function\\s+myFunction', include='*.js') default_api.write_file(content, file_path) Purpose: Writes content to a specified file. Best Practices: Always use absolute paths. Use with caution as it overwrites existing content. Ensure content is correctly formatted and encoded. Example: default_api.write_file(content='Hello World', file_path='/path/to/new_file.txt') default_api.replace(file_path, new_string, old_string, expected_replacements) Purpose: Replaces text within a file. Best Practices: Highly sensitive to exact string matching. Always read_file the target content immediately before using replace to construct old_string precisely. For complex, multi-line, or uncertain changes, prefer the fallback method: read_file -> modify in memory -> write_file . Avoid escaping old_string or new_string unless explicitly required by the underlying system. Example: default_api.replace(file_path='/file.txt', old_string='old text', new_string='new text') default_api.glob(pattern, case_sensitive, path, respect_git_ignore) Purpose: Finds files matching specific glob patterns. Best Practices: Efficient for locating files by name or path structure. Can respect .gitignore . Example: default_api.glob(pattern='**/*.py')","title":"1. Filesystem Interaction"},{"location":"agent_capabilities/#2-shell-command-execution","text":"default_api.run_shell_command(command, description, directory) Purpose: Executes a given shell command. Best Practices: Provide a clear description for commands that modify the filesystem or system state. Use & for background processes. Avoid interactive commands. Ensure commands are safe and necessary. Example: default_api.run_shell_command(command='ls -l', description='List files in current directory.')","title":"2. Shell Command Execution"},{"location":"agent_capabilities/#3-web-interaction","text":"default_api.web_fetch(prompt) Purpose: Processes content from URLs (including local/private network) based on instructions in the prompt. Best Practices: Include clear instructions and up to 20 URLs. Useful for summarizing web content or extracting specific data. Example: default_api.web_fetch(prompt='Summarize https://example.com/article') default_api.google_web_search(query) Purpose: Performs a web search using Google Search. Best Practices: Use for finding general information on the internet. Example: default_api.google_web_search(query='Python best practices')","title":"3. Web Interaction"},{"location":"agent_capabilities/#4-memory-management","text":"default_api.save_memory(fact) Purpose: Saves a specific piece of information or fact to long-term memory. Best Practices: Use only for user-specific facts or preferences that should persist across sessions. Do not use for conversational context or general project information. Example: default_api.save_memory(fact='User prefers tabs over spaces.')","title":"4. Memory Management"},{"location":"agent_capabilities/#common-workflows-and-best-practices","text":"Code Modification: Always read_file before replace . For complex changes, use read_file -> in-memory modification -> write_file as a robust fallback. Git Operations: Use run_shell_command for git status , git add , git commit , git push , etc. Always check git status before committing. Python Development: Leverage run_shell_command for pip install , poetry install , pytest , ruff check , black , etc. Always work within virtual environments. Problem Solving: Use search_file_content and glob to understand the codebase. Use google_web_search for external knowledge.","title":"Common Workflows and Best Practices"},{"location":"agent_capabilities/#5-orchestration-of-external-python-development-tools","text":"The agent is capable of orchestrating a wide range of external Python development tools by executing them via default_api.run_shell_command . This allows the agent to leverage industry-standard tools for various development tasks. Formatage de Code : Black, Autopep8 Linting : Pylint, Flake8, Ruff Gestion des D\u00e9pendances : Pipenv, Poetry Tests : Pytest, Unittest Environnements Virtuels : Virtualenv, Conda Documentation : Sphinx, MkDocs Gestion de Version : Git, GitPython Construction et D\u00e9ploiement : Setuptools, Twine Profiling et Performance : cProfile, Py-Spy Gestion des Erreurs et Logging : Logging, Sentry Gestion des Donn\u00e9es : Pandas, SQLAlchemy S\u00e9curit\u00e9 : Bandit, Safety This document will be updated as new tools and capabilities are introduced or refined.","title":"5. Orchestration of External Python Development Tools"},{"location":"cicd/","text":"Int\u00e9gration Continue (CI) avec GitHub Actions Ce document d\u00e9crit la mise en place d'un workflow d'Int\u00e9gration Continue (CI) simple pour votre projet, utilisant GitHub Actions. L'objectif est d'automatiser la v\u00e9rification de la qualit\u00e9 du code \u00e0 chaque modification. 1. Qu'est-ce que l'Int\u00e9gration Continue ? L'Int\u00e9gration Continue (CI) est une pratique de d\u00e9veloppement logiciel o\u00f9 les d\u00e9veloppeurs int\u00e8grent fr\u00e9quemment leur code dans un d\u00e9p\u00f4t partag\u00e9. Chaque int\u00e9gration est ensuite v\u00e9rifi\u00e9e par une construction automatis\u00e9e (build) et des tests automatis\u00e9s. B\u00e9n\u00e9fices : * D\u00e9tection rapide des erreurs. * Am\u00e9lioration de la qualit\u00e9 du code. * R\u00e9duction des risques lors des fusions de code. * Confiance accrue dans la base de code. 2. Workflow de Linting avec ruff Nous avons mis en place un premier workflow simple qui utilise l'outil ruff pour v\u00e9rifier la qualit\u00e9 de votre code Python. Fichier de Configuration Le workflow est d\u00e9fini dans le fichier .github/workflows/lint.yml : name: Lint Code on: push: branches: [ main ] pull_request: branches: [ main ] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v4 with: python-version: '3.x' - name: Install dependencies run: | python -m pip install --upgrade pip pip install ruff - name: Run ruff run: | ruff check . Explication du Workflow name: Lint Code : Le nom du workflow, visible dans l'interface GitHub. on: : D\u00e9finit les \u00e9v\u00e9nements qui d\u00e9clenchent le workflow : push sur la branche main . pull_request ciblant la branche main . jobs: : Contient les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter. Ici, un seul job nomm\u00e9 lint . runs-on: ubuntu-latest : Le job s'ex\u00e9cutera sur une machine virtuelle Ubuntu h\u00e9berg\u00e9e par GitHub. steps: : La s\u00e9quence d'actions \u00e0 r\u00e9aliser : uses: actions/checkout@v3 : T\u00e9l\u00e9charge le code de votre d\u00e9p\u00f4t sur la machine virtuelle. name: Set up Python et uses: actions/setup-python@v4 : Configure un environnement Python (derni\u00e8re version 3.x) n\u00e9cessaire pour ruff . name: Install dependencies : Installe pip et ruff . name: Run ruff : Ex\u00e9cute la commande ruff check . pour analyser votre code. 3. Comment Utiliser ce Workflow ? Commitez et Poussez le Fichier : Le workflow sera actif d\u00e8s que le fichier .github/workflows/lint.yml sera pouss\u00e9 sur votre d\u00e9p\u00f4t GitHub. bash git add .github/workflows/lint.yml git commit -m \"feat: Add GitHub Actions workflow for linting with ruff\" git push D\u00e9clenchement Automatique : Chaque fois que vous pousserez du code sur main ou ouvrirez/mettrez \u00e0 jour une Pull Request vers main , le workflow se lancera automatiquement. 4. Visualiser les R\u00e9sultats et Corriger les Erreurs Interface GitHub : Rendez-vous sur la page de votre Pull Request ou sur l'onglet \"Actions\" de votre d\u00e9p\u00f4t GitHub. Statut : Vous verrez le statut du workflow (en cours, succ\u00e8s, \u00e9chec). Logs D\u00e9taill\u00e9s : En cas d'\u00e9chec, cliquez sur le lien \"Details\" \u00e0 c\u00f4t\u00e9 du job lint . Vous acc\u00e9derez aux logs complets, affichant les messages d'erreur de ruff (lignes concern\u00e9es, type d'erreur, etc.). Correction : Corrigez les erreurs localement, commitez et poussez \u00e0 nouveau. Le workflow se relancera pour valider vos corrections. 5. Le Workflow CI/CD comme Filet de S\u00e9curit\u00e9 Il est crucial de comprendre que ce workflow est un filet de s\u00e9curit\u00e9 . Vous devez toujours ex\u00e9cuter ruff check . (et vos tests) localement avant de pousser votre code. Le CI est l\u00e0 pour : * Garantir que les standards sont respect\u00e9s par tous les contributeurs. * Attraper les erreurs qui auraient pu \u00eatre manqu\u00e9es localement. * Assurer la qualit\u00e9 constante de la branche principale.","title":"CI/CD"},{"location":"cicd/#integration-continue-ci-avec-github-actions","text":"Ce document d\u00e9crit la mise en place d'un workflow d'Int\u00e9gration Continue (CI) simple pour votre projet, utilisant GitHub Actions. L'objectif est d'automatiser la v\u00e9rification de la qualit\u00e9 du code \u00e0 chaque modification.","title":"Int\u00e9gration Continue (CI) avec GitHub Actions"},{"location":"cicd/#1-quest-ce-que-lintegration-continue","text":"L'Int\u00e9gration Continue (CI) est une pratique de d\u00e9veloppement logiciel o\u00f9 les d\u00e9veloppeurs int\u00e8grent fr\u00e9quemment leur code dans un d\u00e9p\u00f4t partag\u00e9. Chaque int\u00e9gration est ensuite v\u00e9rifi\u00e9e par une construction automatis\u00e9e (build) et des tests automatis\u00e9s. B\u00e9n\u00e9fices : * D\u00e9tection rapide des erreurs. * Am\u00e9lioration de la qualit\u00e9 du code. * R\u00e9duction des risques lors des fusions de code. * Confiance accrue dans la base de code.","title":"1. Qu'est-ce que l'Int\u00e9gration Continue ?"},{"location":"cicd/#2-workflow-de-linting-avec-ruff","text":"Nous avons mis en place un premier workflow simple qui utilise l'outil ruff pour v\u00e9rifier la qualit\u00e9 de votre code Python.","title":"2. Workflow de Linting avec ruff"},{"location":"cicd/#fichier-de-configuration","text":"Le workflow est d\u00e9fini dans le fichier .github/workflows/lint.yml : name: Lint Code on: push: branches: [ main ] pull_request: branches: [ main ] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v4 with: python-version: '3.x' - name: Install dependencies run: | python -m pip install --upgrade pip pip install ruff - name: Run ruff run: | ruff check .","title":"Fichier de Configuration"},{"location":"cicd/#explication-du-workflow","text":"name: Lint Code : Le nom du workflow, visible dans l'interface GitHub. on: : D\u00e9finit les \u00e9v\u00e9nements qui d\u00e9clenchent le workflow : push sur la branche main . pull_request ciblant la branche main . jobs: : Contient les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter. Ici, un seul job nomm\u00e9 lint . runs-on: ubuntu-latest : Le job s'ex\u00e9cutera sur une machine virtuelle Ubuntu h\u00e9berg\u00e9e par GitHub. steps: : La s\u00e9quence d'actions \u00e0 r\u00e9aliser : uses: actions/checkout@v3 : T\u00e9l\u00e9charge le code de votre d\u00e9p\u00f4t sur la machine virtuelle. name: Set up Python et uses: actions/setup-python@v4 : Configure un environnement Python (derni\u00e8re version 3.x) n\u00e9cessaire pour ruff . name: Install dependencies : Installe pip et ruff . name: Run ruff : Ex\u00e9cute la commande ruff check . pour analyser votre code.","title":"Explication du Workflow"},{"location":"cicd/#3-comment-utiliser-ce-workflow","text":"Commitez et Poussez le Fichier : Le workflow sera actif d\u00e8s que le fichier .github/workflows/lint.yml sera pouss\u00e9 sur votre d\u00e9p\u00f4t GitHub. bash git add .github/workflows/lint.yml git commit -m \"feat: Add GitHub Actions workflow for linting with ruff\" git push D\u00e9clenchement Automatique : Chaque fois que vous pousserez du code sur main ou ouvrirez/mettrez \u00e0 jour une Pull Request vers main , le workflow se lancera automatiquement.","title":"3. Comment Utiliser ce Workflow ?"},{"location":"cicd/#4-visualiser-les-resultats-et-corriger-les-erreurs","text":"Interface GitHub : Rendez-vous sur la page de votre Pull Request ou sur l'onglet \"Actions\" de votre d\u00e9p\u00f4t GitHub. Statut : Vous verrez le statut du workflow (en cours, succ\u00e8s, \u00e9chec). Logs D\u00e9taill\u00e9s : En cas d'\u00e9chec, cliquez sur le lien \"Details\" \u00e0 c\u00f4t\u00e9 du job lint . Vous acc\u00e9derez aux logs complets, affichant les messages d'erreur de ruff (lignes concern\u00e9es, type d'erreur, etc.). Correction : Corrigez les erreurs localement, commitez et poussez \u00e0 nouveau. Le workflow se relancera pour valider vos corrections.","title":"4. Visualiser les R\u00e9sultats et Corriger les Erreurs"},{"location":"cicd/#5-le-workflow-cicd-comme-filet-de-securite","text":"Il est crucial de comprendre que ce workflow est un filet de s\u00e9curit\u00e9 . Vous devez toujours ex\u00e9cuter ruff check . (et vos tests) localement avant de pousser votre code. Le CI est l\u00e0 pour : * Garantir que les standards sont respect\u00e9s par tous les contributeurs. * Attraper les erreurs qui auraient pu \u00eatre manqu\u00e9es localement. * Assurer la qualit\u00e9 constante de la branche principale.","title":"5. Le Workflow CI/CD comme Filet de S\u00e9curit\u00e9"},{"location":"development_guidelines/","text":"R\u00e8gles de D\u00e9veloppement pour l'Agent Codeur Ce guide d\u00e9taille les bonnes pratiques de d\u00e9veloppement \u00e0 suivre pour l'agent codeur, afin de limiter les probl\u00e8mes li\u00e9s aux op\u00e9rations de remplacement de code et d'assurer la qualit\u00e9 et la maintenabilit\u00e9 du code produit. Ces r\u00e8gles feront partie du kit de bienvenue pour tout nouvel agent d\u00e9veloppeur. 1. Lecture Pr\u00e9alable Toujours lire le fichier avant de tenter un remplacement pour assurer une correspondance exacte du contenu, y compris les espaces, indentations, et caract\u00e8res sp\u00e9ciaux. 2. Strat\u00e9gie de Remplacement \u00c9viter les Cha\u00eenes Multi-lignes pour les Remplacements Directs : Pr\u00e9f\u00e9rer les remplacements simples (une seule ligne, sans caract\u00e8res sp\u00e9ciaux conflictuels pour l'outil replace ). Utilisation de la Solution de Secours pour les Changements Complexes : Pour les changements impliquant : Des modifications multi-lignes. Des indentations complexes. Des caract\u00e8res sp\u00e9ciaux ( \\ , ' , \" ) qui peuvent poser probl\u00e8me \u00e0 l'outil replace . Une incertitude sur le contenu exact du fichier cible. Utiliser la m\u00e9thode de secours : lire le fichier en entier, effectuer les modifications en m\u00e9moire (avec les fonctions de manipulation de cha\u00eenes de Python ou des expressions r\u00e9guli\u00e8res), puis \u00e9crire le fichier modifi\u00e9 en entier. 3. Pr\u00e9cision des Caract\u00e8res Copier-coller directement depuis le contenu du fichier pour construire les cha\u00eenes de remplacement ( old_string , new_string ). Cela permet de pr\u00e9server les espaces, indentations et caract\u00e8res sp\u00e9ciaux exacts. 4. Gestion des Fichiers Volumineux \u00c9valuer la taille du fichier avant de choisir la m\u00e9thode de manipulation. Pour les fichiers tr\u00e8s volumineux, envisager des m\u00e9thodes alternatives ou des outils sp\u00e9cialis\u00e9s (\u00e0 discuter avec l'utilisateur si n\u00e9cessaire). 5. Encodage Explicite Sp\u00e9cifier explicitement l'encodage (par exemple, UTF-8 ) lors de la lecture et de l'\u00e9criture de fichiers pour \u00e9viter les probl\u00e8mes de caract\u00e8res. 6. Documentation et Journalisation Garder une trace des modifications effectu\u00e9es. Utiliser le syst\u00e8me de gestion de versions (Git) pour des commits fr\u00e9quents et des messages descriptifs. Sauvegarder les versions pr\u00e9c\u00e9dentes des fichiers avant de faire des modifications importantes (par exemple, via des fichiers .bak ou des branches Git temporaires). 7. Tests et Validation Toujours tester le code apr\u00e8s des modifications pour s'assurer de son bon fonctionnement. Utiliser des outils de validation (linters, formatteurs, frameworks de test) pour v\u00e9rifier que le code modifi\u00e9 est correct et conforme aux standards du projet. 8. Utilisation d'Outils Sp\u00e9cialis\u00e9s Pour des t\u00e2ches sp\u00e9cifiques (par exemple, manipulation de JSON ou XML), utiliser des biblioth\u00e8ques et outils d\u00e9di\u00e9s plut\u00f4t que de d\u00e9pendre uniquement de l'outil de remplacement g\u00e9n\u00e9rique. 9. Automatisation des T\u00e2ches R\u00e9p\u00e9titives \u00c9crire des scripts pour automatiser les modifications r\u00e9p\u00e9titives et les t\u00e2ches complexes, afin de gagner en efficacit\u00e9 et de r\u00e9duire les erreurs. 10. R\u00e8gles Sp\u00e9cifiques par Langage Ces r\u00e8gles compl\u00e8tent les principes g\u00e9n\u00e9raux et s'appliquent aux particularit\u00e9s de chaque langage : Python Indentation : Toujours conserver l'indentation exacte lors des modifications. Utiliser des outils de formatage (tels que Black ou Autopep8) pour garantir la coh\u00e9rence. Gestion des Fichiers : Sp\u00e9cifier explicitement l'encodage UTF-8 lors de la lecture et de l'\u00e9criture de fichiers. Utiliser pathlib pour une gestion robuste des chemins. Environnements Virtuels : Tester les modifications dans un environnement virtuel pour s'assurer qu'elles ne cassent pas les d\u00e9pendances et pour isoler le projet. Utiliser des outils de gestion d'environnement (tels que Virtualenv ou Conda). Qualit\u00e9 de Code : Appliquer des outils de linting (comme Pylint, Flake8, ou Ruff) et des frameworks de test (comme Pytest ou Unittest) pour valider le code. Gestion de Projet : Utiliser des outils de gestion de d\u00e9pendances (comme Pipenv ou Poetry) et des syst\u00e8mes de gestion de version (comme Git ou GitPython). Documentation : G\u00e9n\u00e9rer et maintenir la documentation avec des outils d\u00e9di\u00e9s (comme Sphinx ou MkDocs). Performance et S\u00e9curit\u00e9 : Utiliser des profileurs (comme cProfile ou Py-Spy) et des outils d'analyse de s\u00e9curit\u00e9 (comme Bandit ou Safety) pour optimiser et s\u00e9curiser le code. Bash Gestion des Espaces et des Guillemets : Toujours \u00e9chapper les espaces dans les chemins de fichiers et les arguments de commande. Utiliser des guillemets pour entourer les variables et les chemins. Caract\u00e8res Sp\u00e9ciaux : \u00c9chapper les caract\u00e8res sp\u00e9ciaux avec des backslashes ou utiliser des guillemets simples ou doubles. Fin de Ligne : Utiliser des outils qui pr\u00e9servent les fins de ligne (LF vs CRLF) selon l'environnement cible. Pr\u00e9f\u00e9rer LF (Unix) pour les scripts Bash. C/C++ Sensibilit\u00e9 aux Espaces et aux Sauts de Ligne : \u00catre tr\u00e8s attentif aux espaces et aux sauts de ligne, surtout dans les directives de pr\u00e9processeur. Gestion des Fichiers d'En-t\u00eate : Modifier les fichiers d'en-t\u00eate avec prudence, car les changements peuvent affecter de nombreux fichiers sources. Compilation et Liens : Toujours recompiler et relier le projet apr\u00e8s des modifications pour s'assurer qu'il n'y a pas d'erreurs de compilation ou de liens. JavaScript Sensibilit\u00e9 aux Points-virgules : Inclure explicitement les points-virgules pour \u00e9viter les ambigu\u00eft\u00e9s. Gestion des Modules et des D\u00e9pendances : Tester les modifications dans un environnement qui reproduit les d\u00e9pendances du projet. Environnements d'Ex\u00e9cution : Tester les modifications dans l'environnement cible (navigateur, Node.js, etc.). 11. R\u00e8gles G\u00e9n\u00e9rales Compl\u00e9mentaires Utiliser des Outils de Formatage : Appliquer des outils comme Black (Python), clang-format (C/C++), ou Prettier (JavaScript) pour maintenir un code bien format\u00e9. Tests Automatiques : Mettre en place des tests automatiques (avec Pytest, Google Test, Jest, etc.) apr\u00e8s chaque modification. Gestion des Versions : Utiliser Git pour suivre les changements, faire des commits fr\u00e9quents avec des messages descriptifs. Prochaines \u00c9tapes : Outils \u00e0 Fournir Pour faciliter l'adh\u00e9rence \u00e0 ces r\u00e8gles, les outils suivants devraient \u00eatre fournis \u00e0 l'agent codeur : Outils de Lecture et \u00c9criture de Fichiers : Avec options pour g\u00e9rer les encodages, les fins de ligne, etc. Biblioth\u00e8ques de Manipulation de Cha\u00eenes : Pour les expressions r\u00e9guli\u00e8res, les op\u00e9rations de cha\u00eenes complexes. Outils de Test et Validation : Linters, formatteurs, frameworks de test. Outils de Journalisation et Suivi : Pour suivre les changements et les sauvegardes. Outils d'Automatisation : Pour les t\u00e2ches r\u00e9p\u00e9titives et les modifications complexes.","title":"Development Guidelines"},{"location":"development_guidelines/#regles-de-developpement-pour-lagent-codeur","text":"Ce guide d\u00e9taille les bonnes pratiques de d\u00e9veloppement \u00e0 suivre pour l'agent codeur, afin de limiter les probl\u00e8mes li\u00e9s aux op\u00e9rations de remplacement de code et d'assurer la qualit\u00e9 et la maintenabilit\u00e9 du code produit. Ces r\u00e8gles feront partie du kit de bienvenue pour tout nouvel agent d\u00e9veloppeur.","title":"R\u00e8gles de D\u00e9veloppement pour l'Agent Codeur"},{"location":"development_guidelines/#1-lecture-prealable","text":"Toujours lire le fichier avant de tenter un remplacement pour assurer une correspondance exacte du contenu, y compris les espaces, indentations, et caract\u00e8res sp\u00e9ciaux.","title":"1. Lecture Pr\u00e9alable"},{"location":"development_guidelines/#2-strategie-de-remplacement","text":"\u00c9viter les Cha\u00eenes Multi-lignes pour les Remplacements Directs : Pr\u00e9f\u00e9rer les remplacements simples (une seule ligne, sans caract\u00e8res sp\u00e9ciaux conflictuels pour l'outil replace ). Utilisation de la Solution de Secours pour les Changements Complexes : Pour les changements impliquant : Des modifications multi-lignes. Des indentations complexes. Des caract\u00e8res sp\u00e9ciaux ( \\ , ' , \" ) qui peuvent poser probl\u00e8me \u00e0 l'outil replace . Une incertitude sur le contenu exact du fichier cible. Utiliser la m\u00e9thode de secours : lire le fichier en entier, effectuer les modifications en m\u00e9moire (avec les fonctions de manipulation de cha\u00eenes de Python ou des expressions r\u00e9guli\u00e8res), puis \u00e9crire le fichier modifi\u00e9 en entier.","title":"2. Strat\u00e9gie de Remplacement"},{"location":"development_guidelines/#3-precision-des-caracteres","text":"Copier-coller directement depuis le contenu du fichier pour construire les cha\u00eenes de remplacement ( old_string , new_string ). Cela permet de pr\u00e9server les espaces, indentations et caract\u00e8res sp\u00e9ciaux exacts.","title":"3. Pr\u00e9cision des Caract\u00e8res"},{"location":"development_guidelines/#4-gestion-des-fichiers-volumineux","text":"\u00c9valuer la taille du fichier avant de choisir la m\u00e9thode de manipulation. Pour les fichiers tr\u00e8s volumineux, envisager des m\u00e9thodes alternatives ou des outils sp\u00e9cialis\u00e9s (\u00e0 discuter avec l'utilisateur si n\u00e9cessaire).","title":"4. Gestion des Fichiers Volumineux"},{"location":"development_guidelines/#5-encodage-explicite","text":"Sp\u00e9cifier explicitement l'encodage (par exemple, UTF-8 ) lors de la lecture et de l'\u00e9criture de fichiers pour \u00e9viter les probl\u00e8mes de caract\u00e8res.","title":"5. Encodage Explicite"},{"location":"development_guidelines/#6-documentation-et-journalisation","text":"Garder une trace des modifications effectu\u00e9es. Utiliser le syst\u00e8me de gestion de versions (Git) pour des commits fr\u00e9quents et des messages descriptifs. Sauvegarder les versions pr\u00e9c\u00e9dentes des fichiers avant de faire des modifications importantes (par exemple, via des fichiers .bak ou des branches Git temporaires).","title":"6. Documentation et Journalisation"},{"location":"development_guidelines/#7-tests-et-validation","text":"Toujours tester le code apr\u00e8s des modifications pour s'assurer de son bon fonctionnement. Utiliser des outils de validation (linters, formatteurs, frameworks de test) pour v\u00e9rifier que le code modifi\u00e9 est correct et conforme aux standards du projet.","title":"7. Tests et Validation"},{"location":"development_guidelines/#8-utilisation-doutils-specialises","text":"Pour des t\u00e2ches sp\u00e9cifiques (par exemple, manipulation de JSON ou XML), utiliser des biblioth\u00e8ques et outils d\u00e9di\u00e9s plut\u00f4t que de d\u00e9pendre uniquement de l'outil de remplacement g\u00e9n\u00e9rique.","title":"8. Utilisation d'Outils Sp\u00e9cialis\u00e9s"},{"location":"development_guidelines/#9-automatisation-des-taches-repetitives","text":"\u00c9crire des scripts pour automatiser les modifications r\u00e9p\u00e9titives et les t\u00e2ches complexes, afin de gagner en efficacit\u00e9 et de r\u00e9duire les erreurs.","title":"9. Automatisation des T\u00e2ches R\u00e9p\u00e9titives"},{"location":"development_guidelines/#10-regles-specifiques-par-langage","text":"Ces r\u00e8gles compl\u00e8tent les principes g\u00e9n\u00e9raux et s'appliquent aux particularit\u00e9s de chaque langage :","title":"10. R\u00e8gles Sp\u00e9cifiques par Langage"},{"location":"development_guidelines/#python","text":"Indentation : Toujours conserver l'indentation exacte lors des modifications. Utiliser des outils de formatage (tels que Black ou Autopep8) pour garantir la coh\u00e9rence. Gestion des Fichiers : Sp\u00e9cifier explicitement l'encodage UTF-8 lors de la lecture et de l'\u00e9criture de fichiers. Utiliser pathlib pour une gestion robuste des chemins. Environnements Virtuels : Tester les modifications dans un environnement virtuel pour s'assurer qu'elles ne cassent pas les d\u00e9pendances et pour isoler le projet. Utiliser des outils de gestion d'environnement (tels que Virtualenv ou Conda). Qualit\u00e9 de Code : Appliquer des outils de linting (comme Pylint, Flake8, ou Ruff) et des frameworks de test (comme Pytest ou Unittest) pour valider le code. Gestion de Projet : Utiliser des outils de gestion de d\u00e9pendances (comme Pipenv ou Poetry) et des syst\u00e8mes de gestion de version (comme Git ou GitPython). Documentation : G\u00e9n\u00e9rer et maintenir la documentation avec des outils d\u00e9di\u00e9s (comme Sphinx ou MkDocs). Performance et S\u00e9curit\u00e9 : Utiliser des profileurs (comme cProfile ou Py-Spy) et des outils d'analyse de s\u00e9curit\u00e9 (comme Bandit ou Safety) pour optimiser et s\u00e9curiser le code.","title":"Python"},{"location":"development_guidelines/#bash","text":"Gestion des Espaces et des Guillemets : Toujours \u00e9chapper les espaces dans les chemins de fichiers et les arguments de commande. Utiliser des guillemets pour entourer les variables et les chemins. Caract\u00e8res Sp\u00e9ciaux : \u00c9chapper les caract\u00e8res sp\u00e9ciaux avec des backslashes ou utiliser des guillemets simples ou doubles. Fin de Ligne : Utiliser des outils qui pr\u00e9servent les fins de ligne (LF vs CRLF) selon l'environnement cible. Pr\u00e9f\u00e9rer LF (Unix) pour les scripts Bash.","title":"Bash"},{"location":"development_guidelines/#cc","text":"Sensibilit\u00e9 aux Espaces et aux Sauts de Ligne : \u00catre tr\u00e8s attentif aux espaces et aux sauts de ligne, surtout dans les directives de pr\u00e9processeur. Gestion des Fichiers d'En-t\u00eate : Modifier les fichiers d'en-t\u00eate avec prudence, car les changements peuvent affecter de nombreux fichiers sources. Compilation et Liens : Toujours recompiler et relier le projet apr\u00e8s des modifications pour s'assurer qu'il n'y a pas d'erreurs de compilation ou de liens.","title":"C/C++"},{"location":"development_guidelines/#javascript","text":"Sensibilit\u00e9 aux Points-virgules : Inclure explicitement les points-virgules pour \u00e9viter les ambigu\u00eft\u00e9s. Gestion des Modules et des D\u00e9pendances : Tester les modifications dans un environnement qui reproduit les d\u00e9pendances du projet. Environnements d'Ex\u00e9cution : Tester les modifications dans l'environnement cible (navigateur, Node.js, etc.).","title":"JavaScript"},{"location":"development_guidelines/#11-regles-generales-complementaires","text":"Utiliser des Outils de Formatage : Appliquer des outils comme Black (Python), clang-format (C/C++), ou Prettier (JavaScript) pour maintenir un code bien format\u00e9. Tests Automatiques : Mettre en place des tests automatiques (avec Pytest, Google Test, Jest, etc.) apr\u00e8s chaque modification. Gestion des Versions : Utiliser Git pour suivre les changements, faire des commits fr\u00e9quents avec des messages descriptifs.","title":"11. R\u00e8gles G\u00e9n\u00e9rales Compl\u00e9mentaires"},{"location":"development_guidelines/#prochaines-etapes-outils-a-fournir","text":"Pour faciliter l'adh\u00e9rence \u00e0 ces r\u00e8gles, les outils suivants devraient \u00eatre fournis \u00e0 l'agent codeur : Outils de Lecture et \u00c9criture de Fichiers : Avec options pour g\u00e9rer les encodages, les fins de ligne, etc. Biblioth\u00e8ques de Manipulation de Cha\u00eenes : Pour les expressions r\u00e9guli\u00e8res, les op\u00e9rations de cha\u00eenes complexes. Outils de Test et Validation : Linters, formatteurs, frameworks de test. Outils de Journalisation et Suivi : Pour suivre les changements et les sauvegardes. Outils d'Automatisation : Pour les t\u00e2ches r\u00e9p\u00e9titives et les modifications complexes.","title":"Prochaines \u00c9tapes : Outils \u00e0 Fournir"},{"location":"installation/","text":"Installation du Patrimoine de Scripts Git Ce document explique comment installer l'ensemble des scripts utilitaires Git dans un nouveau projet \u00e0 l'aide du script d'installation install.sh . L'objectif est de vous permettre de d\u00e9ployer rapidement votre environnement de travail Git standardis\u00e9 sur n'importe quel nouveau projet. 1. Commande d'Installation Rapide Pour installer les scripts, placez-vous \u00e0 la racine de votre nouveau projet et ex\u00e9cutez la commande suivante dans votre terminal : bash -c \"$(curl -fsSL https://raw.githubusercontent.com/labinno01/teams-ai-python-env/main/install.sh)\" Cette commande t\u00e9l\u00e9charge et ex\u00e9cute le script d'installation de mani\u00e8re s\u00e9curis\u00e9e. 2. Que Fait le Script d'Installation ? Le script est con\u00e7u pour \u00eatre transparent et didactique. Voici les \u00e9tapes qu'il r\u00e9alise : V\u00e9rification de curl : Il s'assure que l'outil curl est disponible sur votre syst\u00e8me. Cr\u00e9ation du Dossier : Il cr\u00e9e un dossier .git-scripts/ \u00e0 la racine de votre projet pour y stocker tous les scripts utilitaires. T\u00e9l\u00e9chargement des Scripts : Il t\u00e9l\u00e9charge la derni\u00e8re version de chaque script ( setup-ssh.sh , init-repository.sh , etc.) depuis le d\u00e9p\u00f4t GitHub de r\u00e9f\u00e9rence. T\u00e9l\u00e9chargement de version.json : Il r\u00e9cup\u00e8re le fichier version.json pour que les scripts connaissent leur version actuelle. Permissions : Il rend automatiquement les scripts t\u00e9l\u00e9charg\u00e9s ex\u00e9cutables ( chmod +x ). Mise \u00e0 jour du .gitignore : Il vous propose d'ajouter le dossier .git-scripts/ \u00e0 votre fichier .gitignore pour \u00e9viter de commiter les outils eux-m\u00eames dans votre nouveau projet. Message de Fin : Il affiche un message de succ\u00e8s avec des instructions pour commencer \u00e0 utiliser les scripts. 3. Personnalisation (Utilisation avec un D\u00e9p\u00f4t Priv\u00e9) Si vous avez \"fork\u00e9\" le projet teams-ai-python-env ou si vous souhaitez maintenir votre propre version des scripts dans un d\u00e9p\u00f4t priv\u00e9 , vous pouvez facilement adapter le script. T\u00e9l\u00e9chargez le script install.sh localement au lieu de l'ex\u00e9cuter directement via curl . Modifiez la variable REPO_URL au d\u00e9but du script pour pointer vers votre d\u00e9p\u00f4t. ```bash Remplacez l'URL par l'URL de votre d\u00e9p\u00f4t REPO_URL=\"https://raw.githubusercontent.com/VOTRE_NOM/VOTRE_DEPOT/main\" ``` Si votre d\u00e9p\u00f4t est priv\u00e9, assurez-vous d'avoir configur\u00e9 votre acc\u00e8s SSH et utilisez l'URL SSH de votre d\u00e9p\u00f4t pour que l'authentification se fasse de mani\u00e8re transparente.","title":"Installation"},{"location":"installation/#installation-du-patrimoine-de-scripts-git","text":"Ce document explique comment installer l'ensemble des scripts utilitaires Git dans un nouveau projet \u00e0 l'aide du script d'installation install.sh . L'objectif est de vous permettre de d\u00e9ployer rapidement votre environnement de travail Git standardis\u00e9 sur n'importe quel nouveau projet.","title":"Installation du Patrimoine de Scripts Git"},{"location":"installation/#1-commande-dinstallation-rapide","text":"Pour installer les scripts, placez-vous \u00e0 la racine de votre nouveau projet et ex\u00e9cutez la commande suivante dans votre terminal : bash -c \"$(curl -fsSL https://raw.githubusercontent.com/labinno01/teams-ai-python-env/main/install.sh)\" Cette commande t\u00e9l\u00e9charge et ex\u00e9cute le script d'installation de mani\u00e8re s\u00e9curis\u00e9e.","title":"1. Commande d'Installation Rapide"},{"location":"installation/#2-que-fait-le-script-dinstallation","text":"Le script est con\u00e7u pour \u00eatre transparent et didactique. Voici les \u00e9tapes qu'il r\u00e9alise : V\u00e9rification de curl : Il s'assure que l'outil curl est disponible sur votre syst\u00e8me. Cr\u00e9ation du Dossier : Il cr\u00e9e un dossier .git-scripts/ \u00e0 la racine de votre projet pour y stocker tous les scripts utilitaires. T\u00e9l\u00e9chargement des Scripts : Il t\u00e9l\u00e9charge la derni\u00e8re version de chaque script ( setup-ssh.sh , init-repository.sh , etc.) depuis le d\u00e9p\u00f4t GitHub de r\u00e9f\u00e9rence. T\u00e9l\u00e9chargement de version.json : Il r\u00e9cup\u00e8re le fichier version.json pour que les scripts connaissent leur version actuelle. Permissions : Il rend automatiquement les scripts t\u00e9l\u00e9charg\u00e9s ex\u00e9cutables ( chmod +x ). Mise \u00e0 jour du .gitignore : Il vous propose d'ajouter le dossier .git-scripts/ \u00e0 votre fichier .gitignore pour \u00e9viter de commiter les outils eux-m\u00eames dans votre nouveau projet. Message de Fin : Il affiche un message de succ\u00e8s avec des instructions pour commencer \u00e0 utiliser les scripts.","title":"2. Que Fait le Script d'Installation ?"},{"location":"installation/#3-personnalisation-utilisation-avec-un-depot-prive","text":"Si vous avez \"fork\u00e9\" le projet teams-ai-python-env ou si vous souhaitez maintenir votre propre version des scripts dans un d\u00e9p\u00f4t priv\u00e9 , vous pouvez facilement adapter le script. T\u00e9l\u00e9chargez le script install.sh localement au lieu de l'ex\u00e9cuter directement via curl . Modifiez la variable REPO_URL au d\u00e9but du script pour pointer vers votre d\u00e9p\u00f4t. ```bash","title":"3. Personnalisation (Utilisation avec un D\u00e9p\u00f4t Priv\u00e9)"},{"location":"installation/#remplacez-lurl-par-lurl-de-votre-depot","text":"REPO_URL=\"https://raw.githubusercontent.com/VOTRE_NOM/VOTRE_DEPOT/main\" ``` Si votre d\u00e9p\u00f4t est priv\u00e9, assurez-vous d'avoir configur\u00e9 votre acc\u00e8s SSH et utilisez l'URL SSH de votre d\u00e9p\u00f4t pour que l'authentification se fasse de mani\u00e8re transparente.","title":"Remplacez l'URL par l'URL de votre d\u00e9p\u00f4t"},{"location":"ssh-manager-v3/","text":"Gestionnaire de Cl\u00e9s SSH v3 Ceci est la documentation pour le nouveau gestionnaire de cl\u00e9s SSH bas\u00e9 sur Python. Commandes Voici une liste des commandes disponibles : assist : Configure automatiquement l'acc\u00e8s SSH pour un h\u00f4te \u00e0 partir d'une URL. backup : Sauvegarde le fichier ~/.ssh/config . config-list : Liste les h\u00f4tes configur\u00e9s dans ~/.ssh/config . create : Cr\u00e9e une nouvelle cl\u00e9 SSH. debug : Affiche les informations de d\u00e9bogage sur l'agent SSH. delete : Supprime une cl\u00e9 SSH. init : Charge une ou plusieurs cl\u00e9s dans l'agent SSH. known : G\u00e8re le fichier known_hosts . list : Liste les fichiers de cl\u00e9s priv\u00e9es dans le r\u00e9pertoire ~/.ssh . reload : D\u00e9charge toutes les cl\u00e9s de l'agent, puis charge les cl\u00e9s sp\u00e9cifi\u00e9es. status : Affiche les cl\u00e9s actuellement charg\u00e9es dans l'agent SSH.","title":"SSH Manager v3"},{"location":"ssh-manager-v3/#gestionnaire-de-cles-ssh-v3","text":"Ceci est la documentation pour le nouveau gestionnaire de cl\u00e9s SSH bas\u00e9 sur Python.","title":"Gestionnaire de Cl\u00e9s SSH v3"},{"location":"ssh-manager-v3/#commandes","text":"Voici une liste des commandes disponibles : assist : Configure automatiquement l'acc\u00e8s SSH pour un h\u00f4te \u00e0 partir d'une URL. backup : Sauvegarde le fichier ~/.ssh/config . config-list : Liste les h\u00f4tes configur\u00e9s dans ~/.ssh/config . create : Cr\u00e9e une nouvelle cl\u00e9 SSH. debug : Affiche les informations de d\u00e9bogage sur l'agent SSH. delete : Supprime une cl\u00e9 SSH. init : Charge une ou plusieurs cl\u00e9s dans l'agent SSH. known : G\u00e8re le fichier known_hosts . list : Liste les fichiers de cl\u00e9s priv\u00e9es dans le r\u00e9pertoire ~/.ssh . reload : D\u00e9charge toutes les cl\u00e9s de l'agent, puis charge les cl\u00e9s sp\u00e9cifi\u00e9es. status : Affiche les cl\u00e9s actuellement charg\u00e9es dans l'agent SSH.","title":"Commandes"},{"location":"scripts/utils/commit-push/","text":"Identification ID de l'Exigence : GIT-REQ-003 Nom du Script : commit-push.sh Version : G\u00e9r\u00e9e par les tags Git (ex: v0.1.0) Objectif (Raison d'\u00eatre) : Simplifier et acc\u00e9l\u00e9rer le processus quotidien de sauvegarde du travail en combinant les \u00e9tapes d'indexation, de commit et de push en une seule commande. Description Fonctionnelle (Le \"Quoi\") D\u00e9clencheur : Manuellement par le d\u00e9veloppeur lorsqu'il souhaite enregistrer et synchroniser ses modifications locales avec le d\u00e9p\u00f4t distant. Processus : V\u00e9rification du Contexte : Le script s'assure qu'il est bien ex\u00e9cut\u00e9 \u00e0 l'int\u00e9rieur d'un d\u00e9p\u00f4t Git. V\u00e9rification des Modifications : Il v\u00e9rifie s'il y a des modifications \u00e0 commiter (git status). S'il n'y en a aucune, il informe l'utilisateur et se termine proprement. Configuration Utilisateur : Il appelle la fonction check_git_config de _common.sh pour s'assurer que l'identit\u00e9 de l'utilisateur est configur\u00e9e. Indexation : Il ajoute toutes les modifications actuelles (fichiers modifi\u00e9s, nouveaux et supprim\u00e9s) \u00e0 l'index avec git add .. Message de Commit : Si un argument est pass\u00e9 au script, il est utilis\u00e9 comme message de commit. Sinon, le script demande interactivement \u00e0 l'utilisateur d'entrer un message de commit. Cette saisie est obligatoire. Commit : Il ex\u00e9cute git commit avec le message fourni. Push : Il ex\u00e9cute git push. Le script est con\u00e7u pour fonctionner sur une branche qui suit d\u00e9j\u00e0 une branche distante. R\u00e9sultat Attendu : Toutes les modifications du r\u00e9pertoire de travail sont commit\u00e9es localement avec le message fourni, et ce nouveau commit est pouss\u00e9 vers la branche distante correspondante. Exigences Non-Fonctionnelles (Les \"Contraintes\") Performance : L'ex\u00e9cution est rapide, la dur\u00e9e d\u00e9pendant principalement du volume de donn\u00e9es \u00e0 pousser (git push). S\u00e9curit\u00e9 : Pas de contraintes de s\u00e9curit\u00e9 particuli\u00e8res. Configuration : Aucune. Le script est autonome. Le message de commit peut \u00eatre fourni soit de mani\u00e8re interactive, soit via un argument en ligne de commande. Gestion des Erreurs : Doit se terminer proprement s'il n'y a rien \u00e0 commiter. Doit \u00e9chouer avec un message clair si la commande git commit ou git push \u00e9choue (par exemple, en cas de conflits ou si la branche locale ne suit aucune branche distante). Sp\u00e9cifications Techniques (Le \"Comment\") Langage et D\u00e9pendances : Bash, git. Doit \"sourcer\" _common.sh. Environnement d'Ex\u00e9cution : Tout environnement de type Unix (Linux, macOS, WSL). Entr\u00e9es / Sorties : Arguments en ligne de commande : Optionnel. Une cha\u00eene de caract\u00e8res qui sera utilis\u00e9e comme message de commit. (ex: ./commit-push.sh \"feat: Ajouter une nouvelle fonctionnalit\u00e9\") Sortie standard (stdout) : Retour d'information sur les \u00e9tapes (indexation, commit, push) et leurs r\u00e9sultats. Cas d'Utilisation Exemple d'Appel Interactif : 1 ./scripts/commit-push.sh 2 # Le script demandera le message de commit * Exemple d'Appel Non-Interactif : 1 ./scripts/commit-push.sh \"fix: Corriger un bug d'affichage sur le bouton principal\"","title":"Commit and Push"},{"location":"scripts/utils/documentation_scripts_git/","text":"Documentation des Scripts Utilitaires Git Ce document d\u00e9crit le fonctionnement et l'utilisation des scripts manage_git.sh et restore_generic.sh . Ces outils ont pour but de standardiser et de simplifier la gestion des d\u00e9p\u00f4ts Git au sein de nos projets. 1. manage_git.sh - Le Couteau Suisse Git Ce script est un outil en ligne de commande pour effectuer les op\u00e9rations Git les plus courantes de mani\u00e8re contr\u00f4l\u00e9e et reproductible. Fonctionnalit\u00e9s V\u00e9rification de l'existence d'un d\u00e9p\u00f4t Git. Initialisation d'un nouveau d\u00e9p\u00f4t. Ajout de d\u00e9p\u00f4ts distants (remotes). Cr\u00e9ation d'un commit initial. Envoi des modifications (push) vers une remote. Gestion des environnements o\u00f9 les emojis ne sont pas support\u00e9s. Utilisation Le script s'utilise avec une commande suivie de ses propres arguments. ./manage_git.sh [--no-emoji] <commande> [arguments...] Option Globale --no-emoji : (Optionnel) Force la d\u00e9sactivation des emojis dans les messages de sortie. Le script tente de d\u00e9tecter automatiquement les terminaux non-UTF-8, mais cette option permet de forcer ce comportement. Commandes check Description : V\u00e9rifie si le dossier courant est un d\u00e9p\u00f4t Git. Usage : ./manage_git.sh check Retourne : Un message de succ\u00e8s ou d'erreur et un code de sortie ( 0 si OK, 1 si non). init Description : Initialise un nouveau d\u00e9p\u00f4t Git ( git init ) si aucun n'existe. Usage : ./manage_git.sh init add-remote <nom> <url> Description : Ajoute un nouveau d\u00e9p\u00f4t distant. Usage : ./manage_git.sh add-remote origin git@github.com:user/repo.git Arguments : <nom> : Le nom de la remote (ex: origin , local_backup ). <url> : L'URL SSH ou HTTPS du d\u00e9p\u00f4t distant. initial-commit <message> Description : Ajoute tous les fichiers du projet ( git add . ) et cr\u00e9e le premier commit. Si l'identit\u00e9 Git (nom/email) n'est pas configur\u00e9e, le script la demandera. Usage : ./manage_git.sh initial-commit \"Premier commit du projet\" Argument : <message> : Le message du commit, entre guillemets. push <nom_remote> <nom_branche> Description : Pousse une branche vers une remote sp\u00e9cifi\u00e9e. Usage : ./manage_git.sh push origin main Arguments : <nom_remote> : Le nom de la remote de destination. <nom_branche> : Le nom de la branche \u00e0 pousser. 2. restore_generic.sh - Restauration de Projet Ce script facilite le clonage d'un projet depuis GitHub en s'assurant que l'authentification par cl\u00e9 SSH est correctement configur\u00e9e sur la machine de l'utilisateur. Fonctionnalit\u00e9s V\u00e9rifie la pr\u00e9sence d'une cl\u00e9 SSH existante ( ~/.ssh/id_rsa ). Si aucune cl\u00e9 n'est trouv\u00e9e, il guide l'utilisateur pour en cr\u00e9er une. Affiche la cl\u00e9 publique et des instructions claires pour l'ajouter \u00e0 GitHub. Clone le d\u00e9p\u00f4t sp\u00e9cifi\u00e9 une fois que l'utilisateur a confirm\u00e9 la configuration. Utilisation Le script prend deux arguments obligatoires. ./restore_generic.sh <utilisateur_github/nom_repo> <dossier_destination> Arguments <utilisateur_github/nom_repo> Description : L'identifiant complet du d\u00e9p\u00f4t sur GitHub. Exemple : labinno01/teams-ai-python-env <dossier_destination> Description : Le nom du dossier qui sera cr\u00e9\u00e9 localement pour contenir le projet clon\u00e9. Exemple : mon-projet-restaure Processus pour l'utilisateur Lancer le script avec les bons arguments. Si aucune cl\u00e9 SSH n'est pr\u00e9sente, suivre les instructions pour en cr\u00e9er une. Copier la cl\u00e9 publique affich\u00e9e par le script. Aller sur github.com/settings/keys et ajouter la cl\u00e9. Revenir au terminal et appuyer sur \"Entr\u00e9e\" pour que le script proc\u00e8de au clonage.","title":"Git Scripts Documentation"},{"location":"scripts/utils/documentation_scripts_git/#documentation-des-scripts-utilitaires-git","text":"Ce document d\u00e9crit le fonctionnement et l'utilisation des scripts manage_git.sh et restore_generic.sh . Ces outils ont pour but de standardiser et de simplifier la gestion des d\u00e9p\u00f4ts Git au sein de nos projets.","title":"Documentation des Scripts Utilitaires Git"},{"location":"scripts/utils/documentation_scripts_git/#1-manage_gitsh-le-couteau-suisse-git","text":"Ce script est un outil en ligne de commande pour effectuer les op\u00e9rations Git les plus courantes de mani\u00e8re contr\u00f4l\u00e9e et reproductible.","title":"1. manage_git.sh - Le Couteau Suisse Git"},{"location":"scripts/utils/documentation_scripts_git/#fonctionnalites","text":"V\u00e9rification de l'existence d'un d\u00e9p\u00f4t Git. Initialisation d'un nouveau d\u00e9p\u00f4t. Ajout de d\u00e9p\u00f4ts distants (remotes). Cr\u00e9ation d'un commit initial. Envoi des modifications (push) vers une remote. Gestion des environnements o\u00f9 les emojis ne sont pas support\u00e9s.","title":"Fonctionnalit\u00e9s"},{"location":"scripts/utils/documentation_scripts_git/#utilisation","text":"Le script s'utilise avec une commande suivie de ses propres arguments. ./manage_git.sh [--no-emoji] <commande> [arguments...]","title":"Utilisation"},{"location":"scripts/utils/documentation_scripts_git/#option-globale","text":"--no-emoji : (Optionnel) Force la d\u00e9sactivation des emojis dans les messages de sortie. Le script tente de d\u00e9tecter automatiquement les terminaux non-UTF-8, mais cette option permet de forcer ce comportement.","title":"Option Globale"},{"location":"scripts/utils/documentation_scripts_git/#commandes","text":"check Description : V\u00e9rifie si le dossier courant est un d\u00e9p\u00f4t Git. Usage : ./manage_git.sh check Retourne : Un message de succ\u00e8s ou d'erreur et un code de sortie ( 0 si OK, 1 si non). init Description : Initialise un nouveau d\u00e9p\u00f4t Git ( git init ) si aucun n'existe. Usage : ./manage_git.sh init add-remote <nom> <url> Description : Ajoute un nouveau d\u00e9p\u00f4t distant. Usage : ./manage_git.sh add-remote origin git@github.com:user/repo.git Arguments : <nom> : Le nom de la remote (ex: origin , local_backup ). <url> : L'URL SSH ou HTTPS du d\u00e9p\u00f4t distant. initial-commit <message> Description : Ajoute tous les fichiers du projet ( git add . ) et cr\u00e9e le premier commit. Si l'identit\u00e9 Git (nom/email) n'est pas configur\u00e9e, le script la demandera. Usage : ./manage_git.sh initial-commit \"Premier commit du projet\" Argument : <message> : Le message du commit, entre guillemets. push <nom_remote> <nom_branche> Description : Pousse une branche vers une remote sp\u00e9cifi\u00e9e. Usage : ./manage_git.sh push origin main Arguments : <nom_remote> : Le nom de la remote de destination. <nom_branche> : Le nom de la branche \u00e0 pousser.","title":"Commandes"},{"location":"scripts/utils/documentation_scripts_git/#2-restore_genericsh-restauration-de-projet","text":"Ce script facilite le clonage d'un projet depuis GitHub en s'assurant que l'authentification par cl\u00e9 SSH est correctement configur\u00e9e sur la machine de l'utilisateur.","title":"2. restore_generic.sh - Restauration de Projet"},{"location":"scripts/utils/documentation_scripts_git/#fonctionnalites_1","text":"V\u00e9rifie la pr\u00e9sence d'une cl\u00e9 SSH existante ( ~/.ssh/id_rsa ). Si aucune cl\u00e9 n'est trouv\u00e9e, il guide l'utilisateur pour en cr\u00e9er une. Affiche la cl\u00e9 publique et des instructions claires pour l'ajouter \u00e0 GitHub. Clone le d\u00e9p\u00f4t sp\u00e9cifi\u00e9 une fois que l'utilisateur a confirm\u00e9 la configuration.","title":"Fonctionnalit\u00e9s"},{"location":"scripts/utils/documentation_scripts_git/#utilisation_1","text":"Le script prend deux arguments obligatoires. ./restore_generic.sh <utilisateur_github/nom_repo> <dossier_destination>","title":"Utilisation"},{"location":"scripts/utils/documentation_scripts_git/#arguments","text":"<utilisateur_github/nom_repo> Description : L'identifiant complet du d\u00e9p\u00f4t sur GitHub. Exemple : labinno01/teams-ai-python-env <dossier_destination> Description : Le nom du dossier qui sera cr\u00e9\u00e9 localement pour contenir le projet clon\u00e9. Exemple : mon-projet-restaure","title":"Arguments"},{"location":"scripts/utils/documentation_scripts_git/#processus-pour-lutilisateur","text":"Lancer le script avec les bons arguments. Si aucune cl\u00e9 SSH n'est pr\u00e9sente, suivre les instructions pour en cr\u00e9er une. Copier la cl\u00e9 publique affich\u00e9e par le script. Aller sur github.com/settings/keys et ajouter la cl\u00e9. Revenir au terminal et appuyer sur \"Entr\u00e9e\" pour que le script proc\u00e8de au clonage.","title":"Processus pour l'utilisateur"},{"location":"scripts/utils/init-repository/","text":"Identification ID de l'Exigence : GIT-REQ-002 Nom du Script : init-repository.sh Version : G\u00e9r\u00e9e par les tags Git (ex: v0.1.0) Objectif (Raison d'\u00eatre) : Assister l'utilisateur dans l'initialisation compl\u00e8te d'un nouveau d\u00e9p\u00f4t Git local, en le liant \u00e0 un d\u00e9p\u00f4t distant et en cr\u00e9ant un premier commit propre. Description Fonctionnelle (Le \"Quoi\") D\u00e9clencheur : Manuellement par le d\u00e9veloppeur, dans le dossier racine d'un projet qui n'est pas encore un d\u00e9p\u00f4t Git. Processus : V\u00e9rification Initiale : Le script v\u00e9rifie d'abord si un dossier .git existe d\u00e9j\u00e0. Si c'est le cas, il informe l'utilisateur que le d\u00e9p\u00f4t est d\u00e9j\u00e0 initialis\u00e9 et se termine. Initialisation : Ex\u00e9cute git init pour cr\u00e9er le d\u00e9p\u00f4t local. Configuration Utilisateur : V\u00e9rifie si user.name et user.email sont configur\u00e9s localement. Si non, il demande \u00e0 l'utilisateur de les saisir (en utilisant la fonction check_git_config de _common.sh). Demande du Distant : Demande \u00e0 l'utilisateur de fournir l'URL SSH du d\u00e9p\u00f4t distant (ex: git@github.com:user/repo.git). Ajout du Distant : Ex\u00e9cute git remote add origin . Cr\u00e9ation du README : Cr\u00e9e un fichier README.md avec le nom du dossier du projet comme titre, pour s'assurer que le premier commit ne soit pas vide. Indexation : Ajoute tous les fichiers \u00e0 l'index avec git add .. Message de Commit : Demande \u00e0 l'utilisateur un message pour le commit initial, en proposant \"feat: Initial commit\" comme valeur par d\u00e9faut. Commit Initial : Ex\u00e9cute git commit avec le message fourni. Push Initial (Optionnel) : Demande \u00e0 l'utilisateur s'il souhaite pousser la branche main vers origin. Si oui, ex\u00e9cute git push -u origin main. R\u00e9sultat Attendu : Le dossier courant est un d\u00e9p\u00f4t Git fonctionnel, avec un remote nomm\u00e9 origin configur\u00e9, un fichier README.md, et un premier commit cr\u00e9\u00e9. La branche main est potentiellement d\u00e9j\u00e0 synchronis\u00e9e avec le d\u00e9p\u00f4t distant. Exigences Non-Fonctionnelles (Les \"Contraintes\") Performance : L'ex\u00e9cution doit \u00eatre rapide, limit\u00e9e principalement par le temps de r\u00e9ponse de l'utilisateur aux questions. S\u00e9curit\u00e9 : Aucune information sensible n'est stock\u00e9e ou affich\u00e9e. Configuration : Le script est enti\u00e8rement interactif et ne n\u00e9cessite aucun fichier de configuration. Gestion des Erreurs : Chaque commande git critique (init, remote add, commit, push) doit \u00eatre v\u00e9rifi\u00e9e. En cas d'\u00e9chec, le script doit afficher un message d'erreur clair et s'arr\u00eater. Sp\u00e9cifications Techniques (Le \"Comment\") Langage et D\u00e9pendances : Bash, git. Le script doit \"sourcer\" _common.sh pour les fonctions utilitaires. Environnement d'Ex\u00e9cution : Tout environnement de type Unix (Linux, macOS, WSL). Entr\u00e9es / Sorties : Arguments en ligne de commande : Aucun. Sortie standard (stdout) : Messages de guidage pour l'assistant interactif et retours d'information sur les commandes ex\u00e9cut\u00e9es. Cas d'Utilisation Exemple d'Appel : 1 # Se placer dans le nouveau projet 2 cd ~/projets/mon-nouveau-site 3 # Lancer l'assistant 4 /chemin/vers/les/scripts/init-repository.sh Processus (mis \u00e0 jour) : 1. V\u00e9rification Initiale : ... (inchang\u00e9) 2. Initialisation : Ex\u00e9cute git init. 3. Configuration Utilisateur : ... (inchang\u00e9) 4. Demande du Distant : Demande \u00e0 l'utilisateur de fournir l'URL SSH du d\u00e9p\u00f4t distant. 5. V\u00e9rification du Distant (Nouvelle \u00c9tape) : * Le script ex\u00e9cute git ls-remote en silence. * Si la commande r\u00e9ussit (code de sortie 0), cela signifie que le d\u00e9p\u00f4t existe. * Le script affiche alors un message d'avertissement et demande \u00e0 l'utilisateur s'il souhaite continuer. * Si l'utilisateur ne confirme pas explicitement, le script s'arr\u00eate avec un message expliquant qu'il devrait peut-\u00eatre utiliser git clone. 6. Ajout du Distant : Ex\u00e9cute git remote add origin . 7. Cr\u00e9ation du README : ... (anciennement 6) 8. Indexation : ... (anciennement 7) 9. Message de Commit : ... (anciennement 8) 10. Commit Initial : ... (anciennement 9) 11. Push Initial (Optionnel) : ... (anciennement 10)","title":"Initialize Repository"},{"location":"scripts/utils/release-version/","text":"Identification ID de l'Exigence : GIT-REQ-005 Nom du Script : release-version.sh Version : G\u00e9r\u00e9e par les tags Git (ex: v0.1.0) Objectif (Raison d'\u00eatre) : Automatiser et s\u00e9curiser le processus de cr\u00e9ation d'une release, en garantissant la synchronisation entre le fichier version.json et les tags Git. Description Fonctionnelle (Le \"Quoi\") D\u00e9clencheur : Manuellement par le d\u00e9veloppeur depuis la branche principale ( main ) lorsque le code est stable et pr\u00eat \u00e0 \u00eatre versionn\u00e9. Processus : V\u00e9rification du Contexte : Le script s'assure qu'il est bien ex\u00e9cut\u00e9 \u00e0 l'int\u00e9rieur d'un d\u00e9p\u00f4t Git. Il v\u00e9rifie que le r\u00e9pertoire de travail est \"propre\" (pas de modifications non commit\u00e9es). Choix de la Version : Il lit la version actuelle depuis version.json . Il demande \u00e0 l'utilisateur de choisir le type de la nouvelle version : PATCH , MINEUR , ou MAJEUR . Il calcule le nouveau num\u00e9ro de version (ex: 0.1.0 -> 0.1.1 ). G\u00e9n\u00e9ration des Notes de Version : Pour un PATCH : Le script g\u00e9n\u00e8re automatiquement la liste des commits depuis le dernier tag. Pour un MINEUR : Il demande \u00e0 l'utilisateur de d\u00e9crire la nouvelle fonctionnalit\u00e9. Pour un MAJEUR : Il demande \u00e0 l'utilisateur de justifier le changement non r\u00e9trocompatible. Confirmation : Le script affiche un r\u00e9sum\u00e9 complet : nouvelle version, message du tag. Il demande une confirmation finale avant d'ex\u00e9cuter les changements. Ex\u00e9cution de la Release : Il met \u00e0 jour le num\u00e9ro de version dans le fichier version.json . Il cr\u00e9e un commit avec le message chore(release): Bump version to X.Y.Z . Il cr\u00e9e un tag Git annot\u00e9 ( git tag -a ) avec le message g\u00e9n\u00e9r\u00e9. Il pousse le nouveau commit et le nouveau tag vers le d\u00e9p\u00f4t distant ( origin ). R\u00e9sultat Attendu : Le projet a une nouvelle version officielle, visible dans version.json et dans les tags Git, et synchronis\u00e9e avec le d\u00e9p\u00f4t distant. Exigences Non-Fonctionnelles (Les \"Contraintes\") S\u00e9curit\u00e9 : Le script ne permet pas de cr\u00e9er une release si le code n'est pas dans un \u00e9tat stable (commit\u00e9e). Configuration : Enti\u00e8rement interactif. Sp\u00e9cifications Techniques (Le \"Comment\") Langage et D\u00e9pendances : Bash, git. Doit \"sourcer\" _common.sh . Environnement d'Ex\u00e9cution : Tout environnement de type Unix (Linux, macOS, WSL). Cas d'Utilisation Exemple d'Appel : 1 # Se placer sur la branche main et s'assurer qu'elle est \u00e0 jour 2 git checkout main 3 git pull 4 # Lancer l'assistant de release 5 ./scripts/release-version.sh","title":"Release Version"},{"location":"scripts/utils/setup-git-ssh/","text":"setup-git-ssh.sh Ce script assiste l'utilisateur dans la configuration et le d\u00e9pannage de l'authentification SSH pour Git, en particulier pour GitHub. Il automatise les \u00e9tapes possibles et fournit des instructions claires pour les actions manuelles requises. Fonctionnalit\u00e9s V\u00e9rification et d\u00e9marrage de l'agent SSH : Le script v\u00e9rifie si l'agent SSH est en cours d'ex\u00e9cution et propose de le d\u00e9marrer si ce n'est pas le cas. Ajout de la cl\u00e9 SSH \u00e0 l'agent : Il guide l'utilisateur pour ajouter sa cl\u00e9 priv\u00e9e SSH \u00e0 l'agent, en proposant un chemin par d\u00e9faut et en v\u00e9rifiant si la cl\u00e9 est d\u00e9j\u00e0 charg\u00e9e. V\u00e9rification de la cl\u00e9 publique sur GitHub (manuel) : Le script fournit des instructions claires pour que l'utilisateur v\u00e9rifie manuellement que sa cl\u00e9 publique correspondante est bien ajout\u00e9e \u00e0 son compte GitHub. Acceptation de la cl\u00e9 d'h\u00f4te de GitHub : Il tente une connexion test \u00e0 GitHub pour s'assurer que la cl\u00e9 d'h\u00f4te de GitHub est ajout\u00e9e aux known_hosts de l'utilisateur, ce qui est crucial pour \u00e9viter les avertissements de s\u00e9curit\u00e9 lors des premi\u00e8res connexions. Utilisation Pour ex\u00e9cuter le script, naviguez jusqu'au r\u00e9pertoire scripts/ de votre projet et ex\u00e9cutez : bash setup-git-ssh.sh Suivez les instructions et les invites du script. Il vous guidera \u00e0 travers les diff\u00e9rentes \u00e9tapes et vous fournira des messages de succ\u00e8s ou d'erreur avec des conseils pour r\u00e9soudre les probl\u00e8mes. Exemples d'utilisation D\u00e9marrer l'agent SSH et ajouter une cl\u00e9 : Le script vous demandera si vous souhaitez d\u00e9marrer l'agent SSH s'il n'est pas actif. Ensuite, il vous invitera \u00e0 fournir le chemin de votre cl\u00e9 SSH priv\u00e9e (par exemple, ~/.ssh/id_rsa ou ~/.ssh/github-monprojet ). V\u00e9rifier l'authentification GitHub : Apr\u00e8s avoir configur\u00e9 votre cl\u00e9, le script effectuera un test de connexion \u00e0 GitHub pour confirmer que tout est correctement configur\u00e9 pour les op\u00e9rations Git via SSH. D\u00e9pendances Ce script d\u00e9pend du fichier _common.sh pour les fonctions utilitaires et les ic\u00f4nes. Assurez-vous que _common.sh est pr\u00e9sent dans le m\u00eame r\u00e9pertoire.","title":"Setup SSH"},{"location":"scripts/utils/setup-git-ssh/#setup-git-sshsh","text":"Ce script assiste l'utilisateur dans la configuration et le d\u00e9pannage de l'authentification SSH pour Git, en particulier pour GitHub. Il automatise les \u00e9tapes possibles et fournit des instructions claires pour les actions manuelles requises.","title":"setup-git-ssh.sh"},{"location":"scripts/utils/setup-git-ssh/#fonctionnalites","text":"V\u00e9rification et d\u00e9marrage de l'agent SSH : Le script v\u00e9rifie si l'agent SSH est en cours d'ex\u00e9cution et propose de le d\u00e9marrer si ce n'est pas le cas. Ajout de la cl\u00e9 SSH \u00e0 l'agent : Il guide l'utilisateur pour ajouter sa cl\u00e9 priv\u00e9e SSH \u00e0 l'agent, en proposant un chemin par d\u00e9faut et en v\u00e9rifiant si la cl\u00e9 est d\u00e9j\u00e0 charg\u00e9e. V\u00e9rification de la cl\u00e9 publique sur GitHub (manuel) : Le script fournit des instructions claires pour que l'utilisateur v\u00e9rifie manuellement que sa cl\u00e9 publique correspondante est bien ajout\u00e9e \u00e0 son compte GitHub. Acceptation de la cl\u00e9 d'h\u00f4te de GitHub : Il tente une connexion test \u00e0 GitHub pour s'assurer que la cl\u00e9 d'h\u00f4te de GitHub est ajout\u00e9e aux known_hosts de l'utilisateur, ce qui est crucial pour \u00e9viter les avertissements de s\u00e9curit\u00e9 lors des premi\u00e8res connexions.","title":"Fonctionnalit\u00e9s"},{"location":"scripts/utils/setup-git-ssh/#utilisation","text":"Pour ex\u00e9cuter le script, naviguez jusqu'au r\u00e9pertoire scripts/ de votre projet et ex\u00e9cutez : bash setup-git-ssh.sh Suivez les instructions et les invites du script. Il vous guidera \u00e0 travers les diff\u00e9rentes \u00e9tapes et vous fournira des messages de succ\u00e8s ou d'erreur avec des conseils pour r\u00e9soudre les probl\u00e8mes.","title":"Utilisation"},{"location":"scripts/utils/setup-git-ssh/#exemples-dutilisation","text":"D\u00e9marrer l'agent SSH et ajouter une cl\u00e9 : Le script vous demandera si vous souhaitez d\u00e9marrer l'agent SSH s'il n'est pas actif. Ensuite, il vous invitera \u00e0 fournir le chemin de votre cl\u00e9 SSH priv\u00e9e (par exemple, ~/.ssh/id_rsa ou ~/.ssh/github-monprojet ). V\u00e9rifier l'authentification GitHub : Apr\u00e8s avoir configur\u00e9 votre cl\u00e9, le script effectuera un test de connexion \u00e0 GitHub pour confirmer que tout est correctement configur\u00e9 pour les op\u00e9rations Git via SSH.","title":"Exemples d'utilisation"},{"location":"scripts/utils/setup-git-ssh/#dependances","text":"Ce script d\u00e9pend du fichier _common.sh pour les fonctions utilitaires et les ic\u00f4nes. Assurez-vous que _common.sh est pr\u00e9sent dans le m\u00eame r\u00e9pertoire.","title":"D\u00e9pendances"},{"location":"scripts/utils/sync-remote/","text":"Identification ID de l'Exigence : GIT-REQ-004 Nom du Script : sync-remote.sh Version : G\u00e9r\u00e9e par les tags Git (ex: v0.1.0) Objectif (Raison d'\u00eatre) : Fournir un moyen s\u00fbr de synchroniser la branche de travail locale avec son \u00e9quivalent sur le d\u00e9p\u00f4t distant, en privil\u00e9giant la s\u00e9curit\u00e9 et la clart\u00e9 sur l'\u00e9tat du d\u00e9p\u00f4t. Description Fonctionnelle (Le \"Quoi\") D\u00e9clencheur : Manuellement par le d\u00e9veloppeur, avant de commencer \u00e0 travailler ou lorsqu'il souhaite r\u00e9cup\u00e9rer les derni\u00e8res mises \u00e0 jour. Processus : V\u00e9rification du Contexte : Le script s'assure qu'il est bien ex\u00e9cut\u00e9 \u00e0 l'int\u00e9rieur d'un d\u00e9p\u00f4t Git. R\u00e9cup\u00e9ration des Donn\u00e9es : Il ex\u00e9cute git fetch pour t\u00e9l\u00e9charger les derni\u00e8res informations du remote sans modifier la copie de travail locale. Analyse de l'\u00c9tat : Il compare la branche locale (HEAD) avec la branche distante suivie. Sc\u00e9narios de Synchronisation : \u00c0 jour : Si les deux branches sont identiques, il informe l'utilisateur que tout est synchronis\u00e9 et se termine. En retard : Si la branche distante a de nouveaux commits, il affiche ces commits et demande \u00e0 l'utilisateur s'il souhaite les int\u00e9grer via git pull --ff-only . Cette commande ne fonctionne que si la branche locale n'a pas de nouveaux commits de son c\u00f4t\u00e9 (avance rapide), ce qui \u00e9vite les merges automatiques non d\u00e9sir\u00e9s. En avance : Si la branche locale a des commits qui ne sont pas sur la branche distante, il en informe l'utilisateur et lui sugg\u00e8re d'utiliser commit-push.sh . Divergence : Si les deux branches ont des commits que l'autre n'a pas, il informe l'utilisateur qu'un merge ou un rebase manuel est n\u00e9cessaire pour r\u00e9soudre le conflit. R\u00e9sultat Attendu : La branche locale est mise \u00e0 jour avec les changements du distant si et seulement si cela peut \u00eatre fait de mani\u00e8re \"fast-forward\" (sans conflit de merge). Exigences Non-Fonctionnelles (Les \"Contraintes\") Performance : Rapide, limit\u00e9e par la vitesse de la connexion r\u00e9seau pour git fetch . S\u00e9curit\u00e9 : En utilisant git pull --ff-only , le script \u00e9vite de cr\u00e9er des commits de merge inattendus, laissant \u00e0 l'utilisateur le contr\u00f4le total en cas de branches divergentes. Configuration : Aucune. Le script est enti\u00e8rement interactif. Gestion des Erreurs : \u00c9choue proprement si git fetch ne fonctionne pas ou si le pull ne peut pas \u00eatre effectu\u00e9 en avance rapide. Sp\u00e9cifications Techniques (Le \"Comment\") Langage et D\u00e9pendances : Bash, git. Doit \"sourcer\" _common.sh . Environnement d'Ex\u00e9cution : Tout environnement de type Unix (Linux, macOS, WSL). Entr\u00e9es / Sorties : Arguments en ligne de commande : Aucun. Sortie standard (stdout) : Informations claires sur l'\u00e9tat de synchronisation et guidage interactif. Cas d'Utilisation Exemple d'Appel : 1 # Se placer dans le projet 2 cd ~/projets/mon-projet 3 # Lancer la synchronisation 4 /chemin/vers/les/scripts/sync-remote.sh","title":"Sync Remote"},{"location":"specs/create_command_spec/","text":"Cahier des Charges : Commande sshkeys create Objectif : Impl\u00e9menter la commande create pour g\u00e9n\u00e9rer une nouvelle cl\u00e9 SSH, l'ajouter \u00e0 l'agent, et optionnellement la configurer dans ~/.ssh/config . 1. Nom de la Commande : create (sera une sous-commande du groupe principal cli ) 2. Description CLI (pour l'aide sshkeys create --help ) : Cr\u00e9e une nouvelle cl\u00e9 SSH, la charge dans l'agent et met \u00e0 jour votre fichier ~/.ssh/config. L'empreinte de la cl\u00e9 est affich\u00e9e apr\u00e8s sa cr\u00e9ation pour v\u00e9rification. 3. Syntaxe CLI : sshkeys create <nom_de_la_cl\u00e9> [OPTIONS] 4. Arguments : <nom_de_la_cl\u00e9> * Type Click : click.Argument(\"key_name\") * Description : Nom de base du fichier de la cl\u00e9 SSH (ex: github-perso ). Ce nom sera utilis\u00e9 pour les fichiers ~/.ssh/<nom_de_la_cl\u00e9> et ~/.ssh/<nom_de_la_cl\u00e9>.pub . * Obligatoire : Oui. 5. Options : --host <nom_h\u00f4te> * Type Click : click.Option(\"--host\", type=str, help=\"Sp\u00e9cifie le nom d'h\u00f4te \u00e0 utiliser dans ~/.ssh/config (ex: github.com-work). Si omis, la cl\u00e9 n'est pas ajout\u00e9e \u00e0 config.\") * Description : Sp\u00e9cifie le nom d'h\u00f4te \u00e0 utiliser dans ~/.ssh/config . * Comportement : Si cette option est fournie, la cl\u00e9 sera \u00e9galement ajout\u00e9e \u00e0 ~/.ssh/config en utilisant ce nom_h\u00f4te comme alias et real_host dans l'objet HostConfig pass\u00e9 \u00e0 add_to_ssh_config . * Valeur par d\u00e9faut : Aucune (optionnel). --email <adresse_email> * Type Click : click.Option(\"--email\", type=str, help=\"Sp\u00e9cifie l'email \u00e0 utiliser comme commentaire pour la cl\u00e9.\") * Description : Sp\u00e9cifie l'email \u00e0 utiliser comme commentaire pour la cl\u00e9 (ex: votre@email.com ). * Comportement : La valeur de cette option sera pass\u00e9e comme partie du commentaire ( -C ) \u00e0 ssh-keygen . Si omis, le commentaire sera g\u00e9n\u00e9r\u00e9 sans email sp\u00e9cifique. * Valeur par d\u00e9faut : Aucune (optionnel). --passphrase , -P * Type Click : click.Option(\"--passphrase\", \"-P\", is_flag=True, help=\"Demande une phrase secr\u00e8te pour la cl\u00e9.\") * Description : Demande une phrase secr\u00e8te pour la cl\u00e9. * Comportement : Si ce flag est pr\u00e9sent, la fonction generate_ssh_key doit \u00eatre appel\u00e9e de mani\u00e8re \u00e0 ce que ssh-keygen demande interactivement la phrase secr\u00e8te. Si omis, generate_ssh_key doit \u00eatre appel\u00e9e avec -N \"\" pour cr\u00e9er une cl\u00e9 sans phrase secr\u00e8te. * Valeur par d\u00e9faut : False (flag). --force , -f * Type Click : click.Option(\"--force\", \"-f\", is_flag=True, help=\"Force l'\u00e9crasement d'une cl\u00e9 existante sans demander confirmation.\") * Description : Force l'\u00e9crasement d'une cl\u00e9 existante. * Comportement : La valeur de ce flag sera pass\u00e9e comme argument overwrite \u00e0 la fonction generate_ssh_key . * Valeur par d\u00e9faut : False (flag). 6. Comportement / Logique Interne (Impl\u00e9mentation dans sshkeys/cli.py ) : D\u00e9corateur Click : @cli.command() Signature de la Fonction : def create(key_name: str, host: Optional[str], email: Optional[str], passphrase: bool, force: bool): * Assurez-vous d'importer Optional depuis typing . Validation du Nom de la Cl\u00e9 ( key_name ) : * R\u00e8gles : * Doit contenir uniquement des caract\u00e8res alphanum\u00e9riques (a-z, A-Z, 0-9), des tirets ( - ) ou des underscores ( _ ). * Ne peut pas \u00eatre config ou known_hosts (insensible \u00e0 la casse). * Action en cas d'erreur : Lever une click.BadParameter(message, param_name=\"key_name\") ou click.UsageError(message) . Construction de l'Objet HostConfig pour generate_ssh_key : * Cr\u00e9ez une instance de HostConfig (importez-la depuis sshkeys.core.models ). * host_type : D\u00e9finir \u00e0 \"server\" par d\u00e9faut. (Pour ce prototype, \"server\" est suffisant. L'int\u00e9gration avec detect_host pour les URLs GitHub/GitLab peut \u00eatre une am\u00e9lioration future). * alias : key_name * real_host : host si sp\u00e9cifi\u00e9, sinon key_name . * user : git (valeur par d\u00e9faut simple pour le prototype). * key_path : Path.home() / \".ssh\" / key_name * key_type : ed25519 (valeur par d\u00e9faut simple pour le prototype). * identity_file : None (pour le prototype). * port : 22 (par d\u00e9faut). Gestion de la Passphrase et Interactivit\u00e9 : * Si l'option --passphrase est utilis\u00e9e, la fonction generate_ssh_key doit appeler ssh-keygen de mani\u00e8re \u00e0 ce qu'il demande interactivement la phrase secr\u00e8te \u00e0 l'utilisateur. * Si l'option --passphrase n'est pas utilis\u00e9e, la fonction generate_ssh_key doit appeler ssh-keygen avec l'option -N \"\" pour cr\u00e9er une cl\u00e9 sans phrase secr\u00e8te et \u00e9viter toute interaction. * Pour toutes les autres options ( --host , --email , --force ), la commande create fonctionnera de mani\u00e8re non-interactive, en utilisant les valeurs fournies ou leurs valeurs par d\u00e9faut. Elle ne demandera pas d'informations suppl\u00e9mentaires \u00e0 l'utilisateur. Appel \u00e0 generate_ssh_key : * generate_ssh_key(host_config_instance, overwrite=force) * Assurez-vous que generate_ssh_key g\u00e8re correctement l'absence de -N \"\" pour la passphrase. Ajout \u00e0 ~/.ssh/config (si --host est sp\u00e9cifi\u00e9) : * Si l'option host est fournie : * Construire un objet HostConfig appropri\u00e9 pour add_to_ssh_config . * Appeler add_to_ssh_config(host_config_for_config) . Affichage de l'Empreinte : * Apr\u00e8s la cr\u00e9ation r\u00e9ussie, afficher un message de succ\u00e8s. * Pour afficher l'empreinte, vous pouvez utiliser subprocess.run([\"ssh-keygen\", \"-lf\", str(key_path)]) et capturer sa sortie. Gestion des Erreurs : * Utiliser un bloc try...except Exception as e: pour capturer les erreurs (ex: FileExistsError de generate_ssh_key , click.BadParameter ). * Afficher les messages d'erreur clairs via click.echo(f\"\u274c Erreur : {e}\", err=True) . 7. Fichiers Impact\u00e9s : * sshkeys/cli.py (ajout de la commande create ) * Potentiellement sshkeys/core/ssh.py (si generate_ssh_key doit \u00eatre ajust\u00e9e pour la gestion de la phrase secr\u00e8te).","title":"Create Command Spec"}]}