ðŸ§  Objectif
CrÃ©er une fonction qui :
- DÃ©tecte tous les environnements Python disponibles (Windows + WSL)
- Ne fait cette dÃ©tection complÃ¨te quâ€™au premier lancement (ou sur demande)
- Permet Ã  lâ€™utilisateur de choisir lâ€™environnement
- Stocke ce choix pour les lancements suivants
- VÃ©rifie si lâ€™environnement choisi est toujours disponible
- Permet de rÃ©initialiser ou forcer une nouvelle dÃ©tection

ðŸ› ï¸ Structure proposÃ©e
1. Stockage du choix
Utilise un fichier de config (ex: JSON ou .ini) pour stocker :
{
  "selected_env": "C:\\Users\\FrÃ©dÃ©ric\\AppData\\Local\\Programs\\Python\\Python311\\python.exe"
}

î·™î·š
2. DÃ©tection des environnements
Fonction detect_python_envs() :
- Recherche les exÃ©cutables Python dans :
- %PATH% sous Windows
- where python
- WSL via wsl which python ou wsl -e bash -c "compgen -c python"
- Retourne une liste de chemins valides
3. Choix utilisateur
Fonction prompt_user_choice(env_list) :
- Affiche les environnements dÃ©tectÃ©s
- Permet Ã  lâ€™utilisateur de choisir (via input ou interface)
- Stocke le choix dans le fichier config
4. Chargement au dÃ©marrage
Fonction load_selected_env() :
- Lit le fichier config
- Si vide â†’ relance dÃ©tection
- Si prÃ©sent â†’ vÃ©rifie que le chemin est encore valide (os.path.exists() ou test dâ€™exÃ©cution python --version)
- Si invalide â†’ relance dÃ©tection
5. RÃ©initialisation / ForÃ§age
Fonction reset_env_choice() :
- Supprime ou vide le fichier config
- Relance la dÃ©tection complÃ¨te

ðŸ” Cycle de vie
| Ã‰tape | Action | 
| Premier lancement | DÃ©tection complÃ¨te â†’ Choix utilisateur â†’ Stockage | 
| Lancement suivant | Chargement du choix â†’ VÃ©rification â†’ Activation | 
| Si invalide | DÃ©tection complÃ¨te â†’ Nouveau choix | 
| Si reset forcÃ© | DÃ©tection complÃ¨te â†’ Nouveau choix | 


-----------------------------------------
â”œâ”€â”€ ps.ps1                  # Menu principal PowerShell
â”œâ”€â”€ aliases.ps1             # Fonctions utilitaires
â”œâ”€â”€ tmux-launch.sh          # Lance tmux + environnement WSL
â”œâ”€â”€ scripts/                # Scripts Python
â”‚   â”œâ”€â”€ launch_gemini.py    # Lance Gemini avec clÃ© API
â”‚   â”œâ”€â”€ gemini_main.py      # Interaction avec Gemini
â”‚   â””â”€â”€ ...                 # Autres scripts Ã  venir
1. env.ps1 â€“ DÃ©tection et validation
Contient :
- Detect-PythonEnvs
- Test-PythonPath
- Validate-PythonEnv
- Is-VirtualEnv
- Get-PythonEnvType

ðŸ“ 2. config.ps1 â€“ Gestion du fichier
Contient :
- Ensure-EnvStore
- Show-PythonEnvConfig
- Edit-PythonEnvConfig
- Clear-PythonEnvConfig
- Reset-PythonEnv
- Manage-PythonEnvConfig

ðŸ“ 3. run.ps1 â€“ ExÃ©cution
Contient :
- Show-PythonEnvDetails
- Show-PipModules
- Run-PythonScript

ðŸ“ 4. menu.ps1 â€“ Interface
Contient :
- MainMenu

ðŸ§ 5. wsl-env.sh â€“ Transcription WSL
Contient les Ã©quivalents bash/zsh :
# ~/.wsl-env.sh

CONFIG_PATH="/mnt/c/Users/frede/.config/ps/python_env.txt"

if [ -f "$CONFIG_PATH" ]; then
    PYTHON_ENV=$(cat "$CONFIG_PATH")
    export PYTHON_ENV

    if [[ "$PYTHON_ENV" == wsl:* ]]; then
        PYTHON_ENV_TYPE="WSL"
    elif [[ "$PYTHON_ENV" == *conda* ]]; then
        PYTHON_ENV_TYPE="conda"
    elif [[ "$PYTHON_ENV" == *venv* || "$PYTHON_ENV" == *bin/python* ]]; then
        PYTHON_ENV_TYPE="venv"
    else
        PYTHON_ENV_TYPE="global"
    fi

    export PYTHON_ENV_TYPE
    export PS1="[\$PYTHON_ENV_TYPE] \u@\h:\w\$ "
fi

Ã€ sourcer dans ~/.bashrc ou ~/.zshrc :
source ~/.wsl-env.sh
---------------------------------------
Ã‰tape 4 : Ajout dans le menu PowerShell
Dans ps.ps1, ajoute :
-----------------------------------
ðŸ§  Script : gemini_main.py
import os
import sys
import getpass
import google.generativeai as genai

# ðŸ“ Fichier local pour stocker la clÃ©
KEY_FILE = os.path.join(os.path.expanduser("~"), ".gemini_api_key")

def get_api_key():
    # ðŸ” VÃ©rifie si la clÃ© est dÃ©jÃ  dans les variables d'environnement
    api_key = os.environ.get("GEMINI_API_KEY")
    if api_key:
        return api_key

    # ðŸ“‚ Sinon, vÃ©rifie si elle est stockÃ©e localement
    if os.path.exists(KEY_FILE):
        with open(KEY_FILE, "r") as f:
            return f.read().strip()

    # ðŸ§‘ Demande Ã  l'utilisateur
    print("ðŸ” ClÃ© API Gemini non trouvÃ©e.")
    api_key = getpass.getpass("ðŸ‘‰ Entrez votre clÃ© API Gemini : ").strip()

    # ðŸ’¾ Stocke dans le fichier local
    with open(KEY_FILE, "w") as f:
        f.write(api_key)

    print(f"âœ… ClÃ© API enregistrÃ©e dans {KEY_FILE}")
    return api_key

def main():
    api_key = get_api_key()

    # ðŸ”§ Configure Gemini
    genai.configure(api_key=api_key)

    # ðŸ§  Lance une gÃ©nÃ©ration simple
    model = genai.GenerativeModel("gemini-pro")
    response = model.generate_content("Explique-moi la mÃ©canique quantique en 3 phrases.")
    print("\nðŸ§  RÃ©ponse Gemini :\n")
    print(response.text)

if __name__ == "__main__":
    main()

î·›î·œî·™î·š

ðŸ” RÃ©sumÃ© du fonctionnement
| Ã‰tape | Action | 
| 1ï¸âƒ£ | Cherche GEMINI_API_KEY dans les variables dâ€™environnement | 
| 2ï¸âƒ£ | Si absente, cherche dans ~/.gemini_api_key | 
| 3ï¸âƒ£ | Si absente, demande Ã  lâ€™utilisateur | 
| 4ï¸âƒ£ | Stocke la clÃ© dans le fichier pour les prochaines fois | 
| 5ï¸âƒ£ | Configure Gemini et lance une gÃ©nÃ©ration | 
----------------------------------------------------------------------------

ðŸ§© Plan du gestionnaire dâ€™alias
ðŸ“ Fichier : aliases.ps1
Contiendra :
- ðŸ”§ DÃ©finition des alias
- ðŸ“œ Commande Show-Aliases pour les afficher avec explications
- ðŸ§  Alias intelligents pour :
- pipall â†’ liste tous les modules
- runenv â†’ exÃ©cute un script dans lâ€™environnement actif
- editenv â†’ modifie lâ€™environnement Python
- edittmux â†’ modifie le script tmux
- launchai â†’ lance le script tmux dans WSL

1/ alias.ps1
----------
function Define-Aliases {
    Set-Alias pipall Show-PipModules
    Set-Alias runenv Run-PythonScript
    Set-Alias editenv Edit-PythonEnvConfig
    Set-Alias edittmux Edit-TmuxScript
    Set-Alias launchai Launch-TmuxWSL
    Set-Alias showaliases Show-Aliases
}

function Show-Aliases {
    Write-Host "`nðŸ“œ Alias disponibles :"
    Write-Host "  pipall      â†’ Affiche tous les modules pip installÃ©s"
    Write-Host "  runenv      â†’ ExÃ©cute un script Python dans lâ€™environnement actif"
    Write-Host "  editenv     â†’ Modifie manuellement le chemin Python enregistrÃ©"
    Write-Host "  edittmux    â†’ Ouvre le script tmux pour Ã©dition"
    Write-Host "  launchai    â†’ Lance tmux avec gemini + shell annotÃ©"
    Write-Host "  showaliases â†’ Affiche cette liste"
}

 OÃ¹ et comment gÃ©rer le lancement de WSL
âœ… Option 1 : via un alias PowerShell (launchai)
DÃ©jÃ  prÃ©vu dans aliases.ps1 :
----------------------------------
Fonction Create-PSMenuShortcut
Ajoute cette fonction dans ton script :


function Create-PSMenuShortcut {
    $shortcutPath = "$HOME\Desktop\Launch-PS-Menu.lnk"
    $target = "powershell.exe"
    $scriptPath = "$HOME\OneDrive\projets\teams-ai-python-env\ps.ps1"
    $arguments = "-ExecutionPolicy Bypass -File `"$scriptPath`""
    $wshShell = New-Object -ComObject WScript.Shell
    $shortcut = $wshShell.CreateShortcut($shortcutPath)
    $shortcut.TargetPath = $target
    $shortcut.Arguments = $arguments
    $shortcut.WindowStyle = 1
    $shortcut.Description = "Lance le menu PowerShell principal"
    $shortcut.IconLocation = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
    $shortcut.Save()

    Write-Host "âœ… Raccourci crÃ©Ã© sur le bureau : Launch-PS-Menu.lnk" -ForegroundColor Green
}
function Edit-TmuxScript {
    notepad "$PSScriptRoot\tmux-launch.sh"
}

function Launch-TmuxWSL {
    wsl bash "$PSScriptRoot/tmux-launch.sh"
}

Ce lance WSL avec ton script tmux-launch.sh qui :
- CrÃ©e une session tmux
- Lance gemini dans la premiÃ¨re fenÃªtre
- Lance un shell annotÃ© dans la seconde
----

âœ… Option 2 : depuis le menu principal
# Ajoute une entrÃ©e dans MainMenu :
'6' {
    Launch-TmuxWSL
}
# Et dans lâ€™affichage 
Write-Host "  [6] ðŸ§ Lancer WSL avec tmux et environnement Python"
--------
ðŸ§­ Fonction Create-PSMenuShortcut
Ajoute cette fonction dans ton script :
function Create-PSMenuShortcut {
    $shortcutPath = "$HOME\Desktop\Launch-PS-Menu.lnk"
    $target = "powershell.exe"
    $scriptPath = "$HOME\OneDrive\projets\teams-ai-python-env\ps.ps1"
    $arguments = "-ExecutionPolicy Bypass -File `"$scriptPath`""
    $wshShell = New-Object -ComObject WScript.Shell
    $shortcut = $wshShell.CreateShortcut($shortcutPath)
    $shortcut.TargetPath = $target
    $shortcut.Arguments = $arguments
    $shortcut.WindowStyle = 1
    $shortcut.Description = "Lance le menu PowerShell principal"
    $shortcut.IconLocation = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
    $shortcut.Save()

    Write-Host "âœ… Raccourci crÃ©Ã© sur le bureau : Launch-PS-Menu.lnk" -ForegroundColor Green
}
ðŸ§­ Ajout dans ton menu
Dans la liste :
Write-Host "  [8] ðŸ–¥ï¸ CrÃ©er un raccourci pour le menu PowerShell"
Et dans le switch :
'8' {
    Create-PSMenuShortcut
}
--------------------------
TMUX
>>>>>------------
- ðŸ“ Scripts stockÃ©s dans ton rÃ©pertoire projet
- ðŸ§  Chargement intelligent des variables dâ€™environnement
- ðŸ§° Fonction tmux personnalisÃ©e qui :
- Lance gemini dans la premiÃ¨re fenÃªtre
- Lance un shell dans la seconde
- Affiche le nom + version de lâ€™environnement Python

âœ… Plan dâ€™action
ðŸ“ 1. RÃ©pertoire projet : teams-ai-python-env
Tu y mets tous les scripts, y compris ceux pour WSL.

ðŸ§ 2. Minimal .bashrc (ou .zshrc)
Juste une ligne :
source ~/OneDrive/projets/teams-ai-python-env/wsl-env.sh



ðŸ“œ 3. wsl-env.sh â€“ Chargement des variables
#!/bin/bash

CONFIG_PATH="/mnt/c/Users/frede/.config/ps/python_env.txt"

if [ -f "$CONFIG_PATH" ]; then
    PYTHON_ENV=$(cat "$CONFIG_PATH")
    export PYTHON_ENV

    if [[ "$PYTHON_ENV" == wsl:* ]]; then
        PYTHON_BIN="${PYTHON_ENV#wsl:}"
    else
        PYTHON_BIN="$PYTHON_ENV"
    fi

    PYTHON_VERSION=$("$PYTHON_BIN" --version 2>/dev/null)
    PYTHON_ENV_TYPE="global"

    if [[ "$PYTHON_ENV" == *conda* ]]; then
        PYTHON_ENV_TYPE="conda"
    elif [[ "$PYTHON_ENV" == *venv* || "$PYTHON_ENV" == *bin/python* ]]; then
        PYTHON_ENV_TYPE="venv"
    elif [[ "$PYTHON_ENV" == wsl:* ]]; then
        PYTHON_ENV_TYPE="WSL"
    fi

    export PYTHON_ENV_TYPE
    export PYTHON_VERSION
    export PS1="[\$PYTHON_ENV_TYPE | \$PYTHON_VERSION] \u@\h:\w\$ "
fi

î·›î·œî·™î·š

ðŸ§° 4. tmux-launch.sh â€“ Fonction personnalisÃ©e
#!/bin/bash

source ~/OneDrive/projets/teams-ai-python-env/wsl-env.sh

SESSION="teams-ai"
WINDOW1="gemini"
WINDOW2="shell"

tmux new-session -d -s "$SESSION" -n "$WINDOW1" "gemini"

tmux new-window -t "$SESSION" -n "$WINDOW2"
tmux send-keys -t "$SESSION:$WINDOW2" "echo 'ðŸ Environnement : $PYTHON_ENV_TYPE'" C-m
tmux send-keys -t "$SESSION:$WINDOW2" "echo 'ðŸ“¦ Version     : $PYTHON_VERSION'" C-m
tmux send-keys -t "$SESSION:$WINDOW2" "bash" C-m

tmux attach-session -t "$SESSION"

î·›î·œî·™î·š

ðŸ§  5. Utilisation
Dans WSL :
bash ~/OneDrive/projets/teams-ai-python-env/tmux-launch.sh


Ou crÃ©e un alias :
alias ai-env="bash ~/OneDrive/projets/teams-ai-python-env/tmux-launch.sh"



Tu veux que je tâ€™ajoute une option dans le menu PowerShell pour lancer WSL avec cette commande automatiquement ?

>>>>>------------
pour lancer
bash ~/OneDrive/projets/teams-ai-python-env/tmux-launch.sh
ou crÃ©Ã©r un alias
alias ai-env="bash ~/OneDrive/projets/teams-ai-python-env/tmux-launch.sh"
-----------------------
mise a jour 
ðŸ§ 2. Minimal .bashrc (ou .zshrc)
Juste une ligne :
source ~/OneDrive/projets/teams-ai-python-env/wsl-env.sh
--------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>
ðŸ§  7. ps.ps1 â€“ Script principa
. "$PSScriptRoot\env.ps1"
. "$PSScriptRoot\config.ps1"
. "$PSScriptRoot\run.ps1"
. "$PSScriptRoot\menu.ps1"

MainMenu